# 좋은 코드, 나쁜 코드 (8) 코드를 모듈화하라

date: March 3, 2024
preview: 좋은 코드, 나쁜 코드 8장을 읽고 정리한 글입니다.

---

### 💭 의존성 주입의 사용을 고려하라

하위 문제에 대한 해결책이 항상 하나만 존재하는 것은 아니다. 재구성할 가능성이 있다면 의존성 주입(DIP)를 고려해보자. 


위 예제에서 RouterPlanner는 RoadMap의 구현체인 NorthAmericaRoadMap에 의존하고 있다. 이렇게 되면 추상화 계층이 지저분해지고 코드는 변경에 대해 유연하지 못하다. 

이 문제는 다음과 같이 의존성 주입으로 해결할 수 있다. 


그리고 다음과 같이 사용할 수 있다. 


하지만 이 방식의 단점은 RoutePlanner를 생성하기 전에 RoadMap의 인스턴스를 생성해야 한다는 것이다. 코드가 지저분해지고 복잡하다. 

이 문제는 몇 가지 팩토리 함수를 제공하면 훨씬 더 쉽게 해결할 수 있다. 또한, 팩토리 메서드의 대안으로 의존성 주입 프레임워크를 사용할 수 있다. 


**의존성 주입 프레임워크**

- 의존성 주입 프레임워크를 사용하면 의존성 주입과 관련된 많은 작업을 수동으로 하지 않아도 되기 때문에 개발 작업이 쉬워진다.
- 프레임워크를 사용하면 팩토리 함수의 반복적인 코드를 작성하느라 허우적대지 않고, 대신 매우 모듈화되고 다용도로 사용할 수 있는 코드를 만들 수 있다.

### 💭 인터페이스에 의존하라

구체적인 구현에 의존하면 변경이 제한된다. 가능한 경우 인터페이스에 의존하는 것이 좋다. 인터페이스에 의존하는 것이 더 간결한 추상화 계층과 더 나은 모듈화를 달성할 수 있는 길이다. 

### 💭 클래스는 자신의 기능에만 집중해야 한다

모듈화의 핵심은 변경 사항이 발생한 경우에 그 변경과 직접 관련된 코드만 수정한다는 것이다. 하나의 개념이 여러 클래스에 분산된다면, 이 목표는 깨진다. 이 상황은 클래스가 다른 클래스의 세부 사항에 지나치게 연관되면 발생한다. 

다음 코드에서 Book은 getChapterWordCount()는 Chapter와 관련된 내용을 알고 있다. 


Chapter의 요구사항 변경은 Book에게까지 전파될 수 있다는 문제가 있다. 따라서, 다음과 같이 getChapterWordCount()를 Chapter 내부로 옮기는 것이 적절하다. 


**디미터의 법칙**

한 객체가 다른 객체의 내용이나 구조에 대해 가능한 한 최대한으로 가정하지 않아야 한다는 소프트웨어 공학의 원칙

### 💭 관련 있는 데이터는 함께 캡슐화하라

너무 많은 것들이 한 클래스 내부에 있을 때 문제점이 야기되지만 합리적인 경우에 그렇게 하기도 한다. 이를 통해 코드는 모듈화와 캡슐화를 달성할 수 있다. 

TextBox 클래스의 renderText()는 많은 인자를 전달 받는다. 이 중 관련된 것들을 하나의 클래스로 묶어서 캡슐화하는 것이 좋다. 


또한, TextBox는 상대적으로 하위 수준의 코드일 가능성이 높다. 캡슐화하지 않는다면 상위의 코드 역시 수많은 매개변수를 넘겨야 할 것이다. 


이에 대한 대안은 앞서 언급한 대로 관련성 있는 매개변수를 한 클래스로 묶는 것이다. 

### 💭 반환 유형에 구현 세부 정보가 유출되지 않도록 주의하라

구현 세부 정보가 유출되면 발생하는 문제

- 하위 계층에 대한 정보도 노출될 수 있다.
- 수정이나 재설정이 매우 어려워질 수 있다.

다음 예제는 구현 세부 정보가 유출되는 예이다. ProfilePictureService의 내부에서 ProfilePictureResult를 사용한다. ProfilePictureResult는 HttpResponse.Status를 사용한다. 따라서 ProfilePictureService는 HttpResponse.Status를 사용한다는 정보가 유출된다. 



- ProfilePictureService 클래스를 사용하고 싶은 개발자는 HttpResponse와 관련된 여러 개념을 처리해야 한다. HTTP 상태 코드는 정말 많다.
- ProfilePictureService 클래스의 구현을 변경하는 것은 매우 어렵다. 내부 메서드를 사용하는 모든 코드가 HttpResponse 클래스를 처리해야 하고, 이것은 코드 계층에 의존성이 발생한 것이다.

이 문제를 해결하는 방법은 추상화 계층에 적합한 유형을 반환함으로써 다른 개발자에게 노출되는 개념이 최소화 하는 것이다. 

다음은 반환 유형과 추상화 계층을 일치시키는 결과 반환 클래스를 생성한 결과이다. 


### 💭 예외 처리 시 구현 세부 사항이 유출되지 않도록 주의하라

호출하는 쪽에서 복구하고자 하는 오류에 대해 비검사 예외를 사용하는 경우, 예외 처리 시 구현 세부 정보를 유출하는 것은 큰 문제가 될 수 있다. 


위 코드의 주석은 구현 세부 사항으로 바람직하지 않다. 이것은 추상화 계층 개념을 위반할 뿐만 아니라 신뢰할 수 없고 오류를 일으키기 쉽다. TextSummarizer 클래스는 TextImportanceScorer 인터페이스에 의존하므로 이 인터페이스를 구현하는 어떤 클래스로도 설정할 수 있다. ModeLBasedScorer는 이러한 구현 클래스 중 하나일 뿐이지 유일한 클래스는 아니다. TextSumarizer는 TextImportanceScorer를 구현하는 다른 클래스로 설
정할수있고, 그 클래스는 완전히 다른 유형의 예외를 발생시킬 수도 있다. 


해결책은 추상화 계층에 적절한 예외를 만드는 것이다. 하지만 코드 줄이 더 많아진다는 단점이 있다. 그래도 장단점을 비교했을 때, 얻는 것이 훨씬 더 크다. 



### 💭 요약

- 코드가 모듈화되어 있으면 변경된 요구사항을 적용하기 위한 코드를 작성하기가 쉽다.
- 모듈화의 주요 목표 중 하나는 요구사항의 변경이 해당 요구사항과 직접 관련된 코드에만 영향을 미치도록 하는 것이다.
- 코드를 모듈식으로 만드는 것은 간결한 추상화 계층을 만드는 것과 깊은 관련이 있다.
- 다음의 기술을 사용하여 코드를 모듈화할 수 있다.
    - 의존성 주입
    - 구체적인 클래스가 아닌 인터페이스에 의존
    - 클래스 상속 대신 인터페이스 및 구성의 활용
    - 클래스는 자신의 기능만 처리
    - 관련된 데이터의 캡슐화
    - 반환 유형 및 예외 처리 시 구현 세부 정보 유출 방지