# 8. 코드를 모듈화하라

<!-- TOC -->

* [8. 코드를 모듈화하라](#8-코드를-모듈화하라)
    * [8.1 의존성 주입의 사용을 고려하라](#81-의존성-주입의-사용을-고려하라)
    * [8.2 인터페이스에 의존하라](#82-인터페이스에-의존하라)
    * [8.3 클래스 상속을 주의하라](#83-클래스-상속을-주의하라)
        * [클래스 상속은 문제가 될 수 있다.](#클래스-상속은-문제가-될-수-있다)
        * [진정한 is-a 관계에서 상속은 어떤가?](#진정한-is-a-관계에서-상속은-어떤가)
    * [8.4 클래스는 자신의 기능에만 집중해야 한다.](#84-클래스는-자신의-기능에만-집중해야-한다)
        * [다른 클래스와 지나치게 연관되어 있으면 문제가 될 수 있다.](#다른-클래스와-지나치게-연관되어-있으면-문제가-될-수-있다)
    * [8.5 관련 있는 데이터는 함께 캡슐화하라](#85-관련-있는-데이터는-함께-캡슐화하라)
    * [8.6 반환 유형에 구현 세부 정보가 유출되지 않도록 주의하라](#86-반환-유형에-구현-세부-정보가-유출되지-않도록-주의하라)
    * [8.7 예외 처리 시 구현 세부 사항이 유출되지 않도록 주의하라](#87-예외-처리-시-구현-세부-사항이-유출되지-않도록-주의하라)

<!-- TOC -->

## 8.1 의존성 주입의 사용을 고려하라

- 하드 코드화된 의존성은 문제가 될 수 있다. 추상화 계층이 지저분해지고 코드의 적응성이 제한되기 때문이다.
- 하위 문제에 대해 해결책이 항상 하나만 존재하는 것은 아니다.
- 하위 문제를 재구성하는 방식을 사용하기 위해서 **의존성 주입**은 유용하다.
    - Factory 클래스를 만들어서 생성 로직을 미리 작성해 둘 수 있다.
    - 팩토리 함수를 직접 작성하는 것의 대안으로 DI 프레임워크를 사용할 수도 있다.

## 8.2 인터페이스에 의존하라

- 구체적인 구현에 의존하면 적응성이 제한된다.
- 의존성 주입을 하되 구현체에 직접 의존하는 경우 다른 구현체에 대해서 주입받을 수 없다.

**(결론) 가능한 경우 인터페이스에 의존하자. 더 추상적인 인터페이스에 의존하면 대개의 경우 더 간결한 추상화 계층과 더 나은 모듈화를 달성할 수 있다.**

## 8.3 클래스 상속을 주의하라

- 클래스는 다른 클래스를 상속할 수 있고, 이렇게 해서 클래스 계층이 형성된다.
- 진정한 is-a 관계를 갖는다면 상속이 적절할 수 있다. 하지만, 상속이 야기하는 문제가 치명적일 수 있기 때문에 신중하게 생각하자.
- 많은 경우, `합성 관계(composition)`로 표현 가능하다.

### 클래스 상속은 문제가 될 수 있다.

- 상속의 주요 특징 중 하나는 서브클래스가 슈퍼클래스에 의해 제공되는 모든 기능을 상속한다는 것이다.
- 상속은 추상화 계층에 방해될 수 있다.
- 상속은 적응성 높은 코드의 작성을 어렵게 만들 수 있다.
- 대신, `합성 관계(composition)`를 사용하라.

### 진정한 is-a 관계에서 상속은 어떤가?

- 정답은 없으며, 주어진 상황과 코드에 따라 다름
- 진정한 is-a 관계라도 다음과 같이 주의 사항이 존재한다.
    - `취약한 베이스 클래스 문제(the fragile base class problem)` : 베이스 클래스가 변경되는 경우 서브 클래스가 작동하지 않을 수 있다.
    - `다이아몬드 문제(diamond problem)` : 여러 슈퍼클래스가 동일한 함수의 각각 다른 버전을 제공하는 경우 문제가 발생할 수 있다.(누구로부터 해당 함수를 상속해야 하는가?)
    - `문제가 있는 계층 구조(problematic hierarchy)` : 단일 상속만 가능한 경우, 클래스가 논리적으로 둘 이상의 클래스에 속할 때 문제가 발생할 수 있다.

## 8.4 클래스는 자신의 기능에만 집중해야 한다.

- 모듈화의 핵심 목표 중 하나는 요구 사항이 변경되면 그 변경과 직접 관련된 코드만 수정하는 것이다.
- 단일 개념이 단일 클래스 내에 완전히 포함된 경우라면 위 목표를 달성 가능하다.
- 반대로 하나의 개념이 여러 클래스에 분산되는 경우에는 연관 코드를 모두 수정해야 하는데, 부분적으로 수정 시, 버그가 발생할 수 있다.

### 다른 클래스와 지나치게 연관되어 있으면 문제가 될 수 있다.

- `디미터의 법칙`은 한 객체가 다른 객체의 내용이나 구조에 대해 가능한 한 최대한으로 가정하지 않아야 한다는 소프트웨어 공학의 원칙이다.

**(결론) 자신의 기능에만 충실한 클래스를 만들자. 클래스는 서로에 대한 어느 정도의 지식을 필요로 할 때도 있지만, 가능한 이것을 최소화하는 것이 좋을 때가 많다.**

## 8.5 관련 있는 데이터는 함께 캡슐화하라

- 서로 다른 데이터가 서로 밀접하게 연관되어 있어 그것들이 항상 함께 움직여야 할 경우, 클래스(또는 유사한 구조)로 그룹화하는 것이 합리적이다.
- 코드는 여러 항목의 세부 사항을 다루는 대신, 그 항목들이 묶여 있는 단일한 클래스가 제공하는 상위 수준의 개념을 다룰 수 있다.

**(결론) 캡슐화되지 않은 데이터는 취급하기 어려울 수 있다. 관련된 데이터는 객체 또는 클래스로 그룹화하자.**

## 8.6 반환 유형에 구현 세부 정보가 유출되지 않도록 주의하라

- 간결한 추상화 계층을 가지려면 각 계층의 구현 세부 정보가 유출되지 않아야 한다.
- 구현 세부 정보가 유출되면 코드의 하위 계층에 대한 정보가 노출될 수 있으며, 향후 수정이나 재설정이 매우 어려워질 수 있다.

**(결론) 반환 형식에 구현 세부 사항이 유출될 경우 문제가 될 수 있다. 추상화 계층에 적합한 유형을 반환하자.**

## 8.7 예외 처리 시 구현 세부 사항이 유출되지 않도록 주의하라

**(결론) 예외 처리 시 구현 세부 사항이 유출되면 문제가 될 수 있다. 추상화 계층에 적절한 예외를 만들자.(예외 감싸기 기법 사용 가능)**
