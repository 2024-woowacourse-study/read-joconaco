# Chpter8 코드를 모듈화하라

다룰 내용
- 모듈화된 코드의 이점
- 이상적인 코드 모듈화가 되지 않은 일반적인 방식
- 코드를 좀 더 모듈화하기 위한 방법

요구사항이 바뀌는 것은 에측이 거의 불가능

모듈화의 주된 목적 중 하나
- 코드가 향후에 어떻게 변경 or 재구성될지 정확히 알지 못한 상태에서 변경 or 재구성이 용이한 코드 작성하는 것.
  - 이를 달성하기 위한 핵심 목표 -> 각각의 기능이 코드의 서로 다른 부분에서 구현


모듈화된 코드는 재사용 및 테스트에 적합


## 8.1 의존성 주입의 사용을 고려하라

하위 문제에 대해 해결책이 여러 개 존재할 수 있으니 재구성할 수 있는 방식으로 코드 작성 유용.  
의존성 주입은 이를 달성하는데 도움이 될수 있음

### 8.1.1 하드 코드화된 의존성은 문제가 될 수 있다

예시) 여행 플래너 클래스, 지도 변수 포함. 지도가 북미로 고정

예시와 같이 구현한다면 다른 구현으로 코드 재설정 불가능.  
추가로 북미 지도가 수정되어 생성자 매개변수가 필요하다면 이 또한 하드코딩 -> 추상화 계층 지저분, 적응성 제한.  
장점은 인스턴스 생성 쉬운게 끝  

### 8.1.2 해결책: 의존성 주입을 사용하라

예시) 지도를 **주입**함으로 모듈화 및 다용도 가능.  
여행 플래스 생성자가 좀 복잡해진다는 단점 -> 팩토리 함수를 통해 해결 가능  
-> 대안으로 *의존성 주입 프레임워크* 사용

#### 의존성 주입 프레임 워크

의존성 주입과 관련된 많은 작업을 자동 -> 반복적 팩토리 함수 코드 작성 줄이고 모듈화 및 다용도 사용 가능 코드 작성

주의할 점
파악하기 어려운 코드 생성 가능 <- 프레임워크 설정 때문  
프레임워크 모범 사례 참고 바람직

### 8.1.3 의존성 주입을 염두에 두고 코드를 설계하라

의식적으로 의존성 주입 고려 유용. 나중에 사용하고 싶어도 불가능한 코드가 만들어질 수 있게 때문

예시) 정적 함수를 가지는 북미 지도 클래스. 인스턴스가 아니라 정적 함수에 의존함  
전과 마찬가지로 북미 지도 밖에 못씀. 하지만 더 심각. 의존성 주입 하게 수정 못함  
지도를 인스턴스로 만들어 사용하면 의존성 주입 가능 -> 코드 적응성 증가

문제 해결책이 하나라 생각하고 간단하게 정적 함수 작성시 문제가 될 수 있음

>정적 매달림  
->정적 함수(변수)에 과도하게 의존하는것. 잠재적 문제가 잘 알려짐. 특히 단위 테스트 코드에서 문제 가능 <- 테스트 더블을 사용할 수 없기 때문

---

의존성 주입
- 여러 개의 하위 문제 해결책에 중요
- 전역 상태 피하는 데 도움
- 테스트하기 쉬운 코드 작성

## 8.2 인터페이스에 의존하라

이는 코드를 모듈화하고 적응성을 높이기 위한 일반적인 기술

### 8.2.1 구체적인 구현에 의존하면 적응성이 제한된다

예시) 북미 지도로 여행 플래너 구성

### 8.2.2 해결책: 가능한 경우 인터페이스에 의존하라

추상적인 인터페이스에 의존하면 대개 더 간결한 추상화 계층과 나은 모듈화 달성

---

인터페이스가 필요한 정의 동작 -> 다른 개발자가 다르게 구현한 클래스 작성-> 코드 모듈화 및 적응성 강화

>의존성 역전 원리  
구체적인 구현보다 추상화에 의존하는 것이 낫다는 생각은 이 원리의 핵심임


## 8.3 클래스 상속을 주의하라

상속은 두 가지 사물이 진정한 is-a 관계를 갖는다면 적절할 수 있음

많은 경우 상속 대신 **구성**을 사용할 수 있음. 클래스 확장보다 인스턴스를 가짐으로 구성할 수 있음.  
1. 상속의 함정 피할 수 있음
2. 모듈화 및 내구성 향상된 코드 작성

### 8.3.1 클래스 상속은 문제가 될 수 있다

예시) 쉼표 구분된 정수 파일 열고 정수 하나씩 읽는 클래스 작성  
csv파일핸들러를 상속받아 구현한 정수파일리더

#### 상속은 추상화 계층에 방해가 될 수 있다

원하는 것보다 더 많은 기능이 노출될 수 있음 -> 추상화 계층 복잡 및 세부 구현 정보 드러남

#### 상속은 적응성 높은 코드의 작성을 어렵게 만들 수 있다

만약 쉼표뿐 아니라 세미콜론으로 구분된 값도 읽어야 한다면 복잡함. 클래스를 새로 만들어도 코드의 중복을 일으킴

### 8.3.2 해결책: 구성을 사용하라

>위임  
함수 전달하는 것. 지루한 작업. 기본 or 추가로 제공되는 기능을 통해 쉽게 처리 지원  
>- 자바의 롬복 프로젝트의 Delegate 애너테이션
>- 코틀린은 기본적으로 지원

구성을 사용하면 코드 재사용 이점 및 상속 관련 문제 회피

#### 더 간결한 추상화 계층

상속받으면 슈퍼클래스의 기능을 외부로 노출

#### 적응성이 높은 코드

세미콜론도 지원해야하면 의존성 주입을 통해 쉽게 해결

### 8.3.3 진정한 is-a 관계는 어떤가?

두 클래스가 진정으로 is-a 관계일 때 조차 상속이 좋은 접근법인지 명확하지 않을 수 있음. 답은 없으며 상황과 작업 중인 코드에 따라 다름

진정한 관계여도 주의할 점
1. 취약한 베이스 클래스 문제: 슈퍼클래스가 수정되면 서브클래스 작동 안할 수 있음
2. 다이아몬드 문제: 다중 상속 시, 동일 함수 각각 다른 버전 제공 문제
3. 문제가 있는 계층 구조: 클래스는 오직 한 클래스 확장. 이는 단일 상속. 계층 구조에 문제 가능. 아래 해결책.
  - 인터페이스 사용하여 계층 구조 정의
  - 구성을 사용하여 코드 재사용

>믹스인과 트레이트  
일부 언어에서 지원되는 기능. 상속 않고도 해당 클래스의 기능 일부 사용 및 공유.  
상속 문제 일부 해결에 도움됨. 그래도 여전히 간결 추상화과 적응성 낮을 수 있음

## 8.4 클래스는 자신의 기능에만 집중해야 한다

### 8.4.1 다른 클래스와 지나치게 연관되어 있으면 문제가 될 수 있다

예시) 책 클래스의 챕터문자세기 메서드. 이는 챕터 클래스에 관련된 사항을 다루며 관련 세부 사항이 그 메서드에 하드 코딩  
챕터 관련 요구사항 변경이 책과 챕터 클래스 둘다 영향

### 8.4.2 해결책: 자신의 기능에만 충실한 클래스를 만들라

자신의 기능에만 충실 -> 코드 모듈화 유지, 한가지 사항이 코드 한 부분만 영향

>디미터의 법칙  
한 객체가 다른 객체의 내용이나 구조에 대해 가능한 한 최대한으로 가정하지 않아야 한다는 소프트웨어 공학의 원칙. 특히 한 객체는 직접 관련된 객체와만 상호작용 해야 한다고 주장

---

코드 모듈화 핵심 목적 중 하나
- 요구 사항 변경 필요 시, 직접 관련 코드만 변경

코드 의존성 최소화 바람직. 이를 통해 코드 모듈화 및 적응성, 유지관리성 크게 개선

## 8.5 관련 있는 데이터는 함께 캡슐화하라

서로 다른 데이터가 밀접 연관 및 함께 움직여야 한다면 클래스로 그룹화 하는 것이 합리적 -> 클래스가 제공하는 상위 수준 개념 다룰 수 있음-> 모듈화

### 8.5.1 캡슐화되지 않은 데이터는 취급하기 어려울 수 있다

예시) TextBox 클래스 및 출력 메서드. 더 상위 수준 클래스에게 호출될 것. 추가로 UI설정 클래스의 게터를 통해 출력 메서드의 스타일 정보 입력 -> 캡슐화되지 않아 스타일 정보를 상위 수준 클래스가 알아야함.   
추가로 스타일 요구사항 변경 시, 상위 메서드도 수정해야하는 것은 안좋음

### 8.5.2 해결책: 관련된 데이터는 객체 또는 클래스로 그룹화하라

예시) 스타일에 관한 데이터를 모은 TextOptions 캡슐화 클래스.

>데이터 객체의 대안  
데이터 캡슐화는 데이터 객체의 또 다른 용례.  
OOP 전통적 관점 지지하는 사람들은 데이터 전용 객체를 안티 패턴으로 간주.  
이전 예시로 해결책은 스타일 정보와 텍스트 스타일을 구현하는 논리를 같은 클래스에 두는 방법. 여전히 데이터 캡슐화 함

---

캡슐화 주의해야함. 한 클래스 너무 많은 개념 문제 가능.

서로 밀접 연관 or 모든 데이터 요구한다면 캡슐화 합리적


## 8.6 반환 유형에 구현 세부 정보가 유출되지 않도록 주의하라

구현 세부 정보 유출하는 일반적 형태 중 하나는 세부 정보와 밀접 연결된 타입 반환하는 것

### 8.6.1 반환 형식에 구현 세부 사항이 유출될 경우 문제가 될 수 있다

예시) 프로필 사진 조회 메서드. httpFetcher 를 사용해 구현. 반환값에 http 관련 내용 포함하여 http 연결 사실을 유출.
나쁜 결과 예시
1. 클래스 사용하려면 http 관련 여러 개념 처리해야함. 수많은 지식 필요
2. 구현 변경이 매우 어려움. http가 아니라 웹소켓을 사용한다면 변경 힘듬

### 8.6.2 해결책: 추상화 계층에 적합한 유형을 반환하라

노출할 최소한의 개념
1. 요청 성공 or 다음 이유 중 하나로 실패
  - 사용자 존재 X
  - 서버 연결 불가능 오류
2. 프로필 사진 데이터 바이트 값

위 처럼 할 경우 중요한 변경사항
1. http.status 열거형보다 사용자 지정 열거형 사용하여 신경쓸 상태만 정의
2. http.Payload 대신 바이트 리스트 반환

>열거형  
열거형 vs 다형성 의견 차이 있음.   
핵심 포인트, 둘 중 뭐든 추상화 계층에 적합한 형식을 사용해야 함

---

언뜻 코드 재사용 위해 httpResponse.속성 재사용이 좋은 방법 처럼 보임.  
이런 반환 유형은 추상화 계층에 적합하지 않음. 

외부로 노출할 개념 최소화 유형 정의 -> 모듈화 및 간결한 추상화 계층

## 8.7 예외 처리 시 구현 세부 사항이 유출되지 않도록 주의하라

호출 쪽에서 복구하고자 하는 오류에 비검사 예외 사용 시, 예외 처리 시 구현 세부 정보 유출은 특히 문제 가능

### 8.7.1 예외 처리 시 구현 세부 사항이 유출되면 문제가 될 수 있다

비검사 예외 핵심 기능 중 하나 - 컴파일러에 강제되지 않음.

의존성 주입으로 문제 해결 시 다양한 예외 유형 발생 가능. 예외 처리문이 잘 처리 못함

### 8.7.2 해결책: 추상화 계층에 적절한 예외를 만들라

코드의 각 계층이 주어진 추상화 계층을 반영하는 오류 유형만 드러내는 것이 이상적 <- 하위 계층 오류를 현재 계층 오류로 감싸면 가능 <- 추상화 제시 및 오류 정보 손실 X

단점은 명확, 사용자 지정 예외 클래스 정의 및 다양한 예외 처리 및 감싼 후 다시 발생으로 코드 많아짐 <- 예측 가능, 모듈화 개선 장점이 이득

---

호출 쪽에서 오류 복구 안하는 것 확실하면, 세부 정보 유출 큰 문제X, 아니라면 잘 확인

## 요약

- 코드 모듈화
  - 요구 사항 변경 쉬움
    - 변경 시 직접 관련 코드에만 영향 미치도록 하는 것
- 모듈식은 간결한 추상화 계층 만드는 것과 깊은 관련
- 코드 모듈화 기술
  1. 의존성 주입
  2. 구체적 클래스보다 인터페이스 의존
  3. 상속 대신 인터페이스 및 구성 활용
  4. 클래스는 자신의 기능만 처리
  5. 관련 데이터 캡슐화
  6. 반환 유형 및 예외 처리 시 세부 구현 유출 방지

