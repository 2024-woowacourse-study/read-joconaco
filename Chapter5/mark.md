# Chapter5 가독성 높은 코드를 작성하라

#### 다룰 내용
- 코드가 그 자체로 설명 되도록 하기 위한 방법
- 코드의 세부적 내용을 명확하게 함
- 언어의 기능을 사용할 때 합당한 이유 가져야함

가독성을 위한 가장 일반적이고 효과적인 기법의 확실한 토대 제공

## 5.1 서술형 명칭 사용

클래스, 함수, 변수들을 고유하게 식별할 이름 필요. 스스로 설명되는 방식으로 언급함

### 5.1.1 서술적이지 않은 이름은 코드를 읽기 어렵게 만든다

함수명이 `f()` 변수명이 `a` 면 어떤 개념 나타내는지 모름

### 5.1.2 주석문으로 서술적인 이름을 대체할 수 없다

주석을 주로 달면
- 코드가 더 복잡해 보임. 주석도 유지보수 해야함
- 많은 스크롤 해야함
- 여전히 뭘 하는지 알기 어려움

주석은 코드 사용법 이해에 도움 되지만 서술적 이름을 대신 하면 안됨

### 5.1.3 해결책: 서술적인 이름 짓기

- 변수, 함수, 클래스가 별도 설명 필요 없이 자명
- 코드만 봐도 뭘 반환할지 예상 되는 등 가독성 향상

예시로 `containsPlayer(String playerName)`, `playerNames` 등 이해하기 쉬움

## 5.2 주석문의 적절한 사용

주석문, 문서화는 다음 목적 수행
1. 코드가 **무엇**을 하는지 설명
2. 코드가 **왜** 그 일을 하는지 설명
3. 사용 지침 등 기타 정보 제공

이번 절은 처음 두 가지 중점적 설명

코드가 왜 그 일을 하는지 이유 or 배경 설명하는 주석문은 유용할때가 많음, 코드만으로는 이를 명확히 할 수 없기 때문

>상식의 사용  
지침을 제공하지만 반드시 따를 규칙 아님. 좋은 코드를 상식적으로 생각하여 작성.

### 5.2.1 중복된 주석문은 유해할 수 있다

코드 자체로 설명 될 때 주석은 쓸모 없는 것 이상으로 더 나쁨
1. 주석문도 유지보수 해야함
2. 코드 지저분

### 5.2.2 주석문으로 가독성 높은 코드를 대체할 수 없다

프리코스에서 아래 예시의 안좋은 코드를 작성했었음

```
// data[0]는 유저의 이름이고 data[1]은 성이다.
data[0] + ." + data[1]
->
String generateld(String[] data) { return firstName(data) + lastName(data); }
String firstName (String[] data) { return data[0]; }
```

### 5.2.3 주석문은 코드의 이유를 설명하는 데 유용하다

코드가 왜 그 일하는지 코드로 설명 어려움. 이러한 배경 상황 or 지식이 코드 수정에 중요한 경우 주석문 매우 유용

다음 코드 존재 이유 설명 좋음
- 제품 or 비즈니스 의사 결정
- 이상하고 명확하지 않은 버그 해결책
- 의존하는 코드의 예상을 벗어난 동작 대처

### 5.2.4 주석문은 유용한 상위 수준의 요약 정보를 제공할 수 있다

주석문, 문서는 마치 책의 줄거리 같음
- 모든 페이지 단락에 줄거리 있다면 가동성 떨어짐 <- 하위 수준 주석문
- 각 장의 시작 등 간략한 요약은 매우 유용. <- 상위 수준 주석문

상위 수준 문서는 다음 경우 유용
1. 클래스 수행 작업 및 알아야할 중요한 세부 사항 요약 설명
2. 함수 입력 매개변수 or 기능 설명
3. 함수 반환값이 무엇 나타내는지 설명

## 5.3 코드 줄 수를 고정하지 말라

코드 줄 수는 간접적으로 측정. 엄격한 규칙 x. 중요한 것은 아래 사항
- 이해하기 쉬움, 오해하기 어려움, 실수로 작동 안되기 어려움

### 5.3.1 간결하지만 이해하기 어려운 코드는 피하라

예시 `countSetBits(id & 0x7FFF) % 2 = ((id & 0×8000) »> 15)`  
한 줄이지만 많은 일을 하고 있음  
많은 일을 도출하기 위해 많은 노력, 코드 오해 가능성 큼

### 5.3.2 해결책: 더 많은 줄이 필요하더라도 가독성 높은 코드를 작성하라

코드 줄 수가 늘어나도 이해하기 쉽고, 오해하기 어렵고, 잘 작동하면 그렇게 하는 것이 훨씬 좋음

## 5.4 일관된 코딩 스타일을 고수하라

코드 스타일은 상당히 자유로움. 잘 읽히는 코드를 위해 일관된 스타일 사용

### 5.4.1 일관적이지 않은 코딩 스타일은 혼동을 일으킬 수 있다

일반적인 클래스 및 메서드, 변수 컨벤션을 사용해야 함

### 5.4.2 해결책: 스타일 가이드를 채택하고 따르라

팀이 요구하는 스타일 가이드를 읽고 파악한 후에 그대로 따르면 됨

코딩 스타일의 많은 측면
1. 명명법
2. 언어의 특정 기능 사용
3. 코드 들여쓰기
4. 패키지 및 디렉터리 구조화
5. 코드 문서화 방법

>린터(linter)  
스타일 가이드를 따르지 않은 코드를 찾아 알려주는 도구  
코드를 개선하기 위한 빠르고 쉬운 방법

## 5.5 깊이 중첩된 코드를 피하라

### 5.5.1 깊이 중첩된 코드는 읽기 어려울 수 있다

중첩을 최소화 하도록 코드 구성하는 것이 바람직

모든 if-else 논리를 탐색해야 하기 때문에 읽기 어려움

### 5.5.2 해결책: 중첨을 최소화하기 위한 구조 변경

논리를 재구성하는 것이 쉬울때 많음.

반환문이 있으면 재배치하기 아주 쉬움. 반환문이 없다면 대개 함수가 너무 많은 일 하고 있다는 신호

### 5.5.3 중첨은 너무 많은 일을 한 결과물이다

함수가 많은 일을 하고 있다면 중첩을 최소화하기 힘듬

### 5.5.4 해결책: 더 작은 함수로 분리

코드를 나누면 중첩을 쉽게 제거할 수 있음

함수가 많은 일 하면 추상화 계층 또한 나빠짐. 함수를 쪼개라.

## 5.6 함수 호출도 가독성이 있어야 한다

>많은 함수 인수  
많은 매개변수는 가지고 있으면 근복적인 문제를 나타내는 것일 수 있음

### 5.6.1 매개변수는 이해하기 어려울 수 있다

예시에서 `sendMessage ("hello", 1, true);` 1과 true 가 무엇을 의미하는지 알려면 정의흫 확인해야함. 귀찮음

### 5.6.2 해결책: 명명된 매개변수 사용

함수 호출에서 이를 사용할 때 인수 목록 위치가 아닌 이름으로 일치하는 매개변수 찾음

예시 `sendNessage(message:“hello”, priority: 1, allowRetry: true);`

지원하지 않아고 타스, 자스에서 **객체 구조 분해**를 사용하는 방법이 있음  
객체를 넘기고 분해하여 명명된 매개변수와 같은 효과를 얻음

### 5.6.3 해결책: 서술적 유형 사용

매개변수를 클래스나 열거형으로 서술적이게 만듬

예시 `sendMessage("hello", new MessagePriority(1), RetryPolicy.ALLOW_RETRY);`

### 5.6.4 때로는 훌륭한 해결책이 없다

예시 `BoundingBox box = new BoundingBox (10, 50, 20, 5);`

인자 마다 주석문 다는 방법이 있지만 그리 좋진 않음

세터 함수, 빌더 패턴 등의 대안이 있지만 코드가 쉽게 오용될 수 있는 단점 존재

### 5.6.5 IDE는 어떤가?

백그라운드 작업으로 함수 정의를 미리 찾아놓아 매개변수 이름을 표시해줌

유용하지만 의존하지 않는 것이 좋음. 모두가 쓰는 것도 아니고, 없는 도구도 있기에 도움 없이 코드 봐야함

## 5.7 설명되지 않은 값을 사용하지 말라

하드 코드 값 예시
- 단위를 변환할 때 사용하는 계수
- 작업 실패시 재시도 최대 횟수 등 조정 가능 파라미터 값

값이 무엇을 의미하는지 개발자에게 명확하지 않음

### 5.7.1 설명되지 않은 값은 혼란스러울 수 있다

단위를 변환하는 계수를 하드 코딩하면 무엇을 하는지 모르기에 가독성 떨어뜨림. 이해 못하기에 수정하면 작동안할 가능성 큼

**그 값이 무엇을 의미하는지** 다른 개발자들에게 명확하게 해주는 것이 중요함

### 5.7.2 해결책: 잘 명명된 상수를 사용하라

상수를 정의하고 상수 이름을 통해 값을 설명하는 것

예시 `private const Double KILOGRAMS_PER_US_TON = 907. 1847;`

### 5.7.3 해결책: 잘 명명된 함수를 사용하라

잘 명명된 함수 사용 두가지 방법
1. 상수를 반환하는 공급자 함수
2. 변환을 수행하는 헬퍼 함수

#### 공급자 함수

예시 `private static Double kilogramsPerUsTon() { return 907.1847; }`

#### 헬퍼 함수

단위 변환을 하위 문제로 만들어 전문적으로 수행하는 함수 작성

예시 `private static Double usTonsToKilograms (Double usTons) { return usTons * 907.1847; }`


정의한 값이나 헬퍼 함수를 다른 개발자들이 재사용할 가능성이 있다면 별도의 유틸리티 클래스에 두는 것이 좋음

## 5.8 익명 함수를 적절하게 사용하라

익명 함수는 이름이 없는 함수. 코드 내 필요한 지점에서 인라인으로 정의

- 간단 자명한 것에 사용하면 가독성 증가
- 복잡 자명하지 않은 것or 재사용해야 하는 것은 문제될 수 있음

### 5.8.1 익명 함수는 간단한 로직에 좋다

예시 `feedback >- !feedback.getComment () .isEmpty ( )`

단 한문장이면 충분, 해결 문제 간단. 매우 이해하기 쉽고 단순 명료함

## 5.8.2 익명 함수는 가독성이 떨어질 수 있다

예시 `id >- countSetBits(id & 0x7FFF) % 2 == ((id & 0x8000) >> 15)`

간단하지만 이해하기 어려움

### 5.8.3 해결책: 대신 명명 함수를 사용하라

예시 `private Boolean isParityBitCorrect (UInt16 id) { ... }`

상위 함수를 이해하기 위해 세부 사항 이해 안해도 됨. 또 재사용 하기 쉬움

간단 자명 -> 익명 함수, 복잡 논리 -> 명명 함수

### 5.8.4 익명 함수가 길면 문제가 될 수 있다

**함수형 스타일** 은 익명 함수와 다름.

익명 함수가 두세 줄 이상으로 늘어나기 시작할 때, 여러개의 명명 함수로 분리하면 코드의 가독성이 좋아짐.

많은 일 하는 함수는 익명 함수가 아니라 명명 함수여도 문제. 익명이면 더 나쁘긴 함

### 5.8.5 해결책: 긴 익명 함수를 여러 개의 명명 함수로 나누라

많은 일 하는 큰 함수를 분리하는 것은 가독성, 재사용성, 모듈화 개선에 좋은 방법


## 5.9 프로그래밍 언어의 새로운 기능을 적절하게 사용하라

언어 설계자는 새로운 기능 추가에 매우 신중. 사용하면 가독성, 견고 해질 수 있음

사용하고 싶을 때, 정말 그 일에 적합한 도구인지 솔직하게 생각해야 함

### 5.9.1 새 기능은 코드를 개선할 수 있다

자바8이 스트림 도입시 많은 개발자 선호

무언가 직접 만드는 대신 언어가 제공하는 기능 사용하면 코드 최적화 및 효율적, 버그 없을 가능성 커짐

### 5.9.2 불분명한 기능은 혼동을 일으킬 수 있다

잘 안알려진 기능이면 유지보수하기 힘듬

예시로 스트림 안익숙한데 쓰면 그것이 초래할 혼란이 클 수 있음

다른 개발자가 그 기능에 익숙치 안흥면 안사용하는 것이 좋을 때도 있음

### 5.9.3 작업에 가장 적합한 도구를 사용하라

예시로 자바 스트림은 아주 다재다능해도 맵에서 키에 대한 값 찾는데 `map.get(key);` 면 되는데 굳이 스트림 쓸 필요없음

과장된 예처럼 보여도 필자는 거의 동일한 상황을 봄


## 요약

- 코드 가독성 떨어지면 다음 문제 발생
  - 이해하느라 시간 허비
  - 버그 유발 오해
  - 수정 후 작동 안함
- 가독성 때문에 줄이 길어져도 종종 가치 있는 절충임
- 가독성 위해 다른 개발자 입장으로 공감 및 상상 필요
- 실제 시나리오 다양하니 다 적용하지 말고 언제나 상식 적용, 판단력 사용해야 함


