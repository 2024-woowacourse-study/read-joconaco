# 10.단위 테스트의 원칙

---

## 10.1 단위 테스트 기초
- 테스트 중인 코드: `실제 코드`
- 테스트 코드: 단위 테스트를 구성하는 코드 
- 테스트 케이스
  - 준비 - (given)
  - 실행 - (when)
  - 단언 - (then)
- 테스트 러너 

## 10.2 좋은 단위 테스트는 어떻게 작성할 수 있는가?
- 훼손의 정확한 감지: 코드가 훼손되면 테스트가 실패한다. 그리고 테스트는 코드가 실제로 훼손된 경우에만 실패해야 한다.
- 세부 구현 사항에 독립적: 세부 구현 사항을 변경하더라도 테스트 코드는 변경하지 않는 것이 이상적이다.
- 잘 설명되는 실패: 코드가 잘못되면 테스트는 실패의 원인과 문제점을 명확하게 설명해야 한다.
- 이해할 수 있는 테스트 코드: 다른 개발자들이 테스트 코드가 정확히 무엇을 테스트하기 위한 것이고 테스트가 어떻게 수행되는지 이해할 수 있어야 한다.
- 쉽고 빠르게 실행: 개발자는 일상 작업 중에 단위 테스트를 자주 실행한다. 단위 테스트가 느리거나 실행이 어려우면 개발 시간이 낭비된다.

### 10.2.1 훼손의 정확한 감지
단위 테스트의 가장 명확하고 주된 목표는 코드가 훼손되지 않았는지 확인하는 것이다.
테스트 중인 코드가 훼손되면 테스트가 실패해야 한다. 이것은 두 가지 역할을 수행한다.
- 코드에 대한 초기 신뢰를 준다.
- 미래의 훼손을 막아준다. 

### 10.2.2 세부 구현 사항에 독립적
일반적으로 개발자가 코드베이스에 가할 수 있는 변경은 두 가지 종류가 있다.
- 기능적 변화: 코드가 외부로 보이는 동작을 수정. 예) 새로운 기능 추가, 버그 수정, 에러 처리
- 리팩터링 

> 기능 변경과 리팩터링을 같이 하지 말라

: 코드 베이스를 변경할 때 일반적으로 기능만 변경하거나 리팩터링만 해야지 두 가지 작업을 동시에 수행하는 것은 좋지 않다.
리팩터링은 어떠한 동작도 변경하지 않지만, 기능 변경은 동작을 변경한다. 기능적 변화와 리팩터링을 동시에 하면
기능적 변화로 예상되는 동작의 변화와 리팩터링의 실수로 발생하는 동작의 변화를 구분하기 어려울 수 있다.
보통 리팩터링을 한 다음 기능 변경을 따로 하는 것이 좋다. 이렇게 하면 잠재적인 문제의 원인을 분리하기가 훨씬 더 쉬워진다.

### 10.2.3 잘 설명되는 실패
테스트 실패가 잘 설명되도록 하는 좋은 방법 중 하나는 하나의 테스트 케이스는 한 가지 사항만 검사.
각 테스트 케이스에 대해 서술적인 이름을 사용.

-> 이렇게 하면 한 번에 모든 것을 테스트하려고 하는 하나의 큰 테스트 케이스보다 각각의 특정 동작을 확인하기 위한 작은 테스트 케이스가 많이 만들어진다.

### 10.2.4 이해 가능한 테스트 코드

### 10.2.5 쉽고 빠른 실행
테스트를 빠르고 쉽게 유지해야 하는 이유는 
- 느린 단위 테스트는 개발자의 작업 속도를 느리게 만든다.
- 개발자가 실제로 테스트를 할 수 있는 기회를 극대화하기 위함이다.

## 10.3 퍼블릭 API에 집중하되 중요한 동작은 무시하지 말라
가능하면 퍼블릭 API를 사용하여 코드의 동작을 테스트해야 한다. 
이는 순전히 퍼블릭 함수의 매개변수, 반환값, 오류 전달을 통해 발생하는 동작만 테스트해야 한다는 의미

그러나 코드의 퍼블릭 API를 어떻게 정의하느냐에 따라 퍼블릭 API만으로는 모든 동작을 테스트할 수 없는 경우가 있다.
- 서버와 상호작용하는 코드
- 데이터베이스에 값을 저장하거나 읽는 코드 

## 10.4 테스트 더블
테스트 더블은 의존성을 시뮬레이션하는 객체지만 테스트에 더 적합하게 사용할 수 있도록 만들어진다.
- 목
- 스텁
- 페이크

### 10.4.1 테스트 더블을 사용하는 이유
- 테스트 단순화
- 테스트로부터 외부 세계 보호
- 외부로부터 테스트 보호 

### 10.4.2 목
클래스나 인터페이스를 시뮬레이션하는 데 멤버 함수에 대한 호출을 기록하는 것 외에는 어떠한 일도 수행하지 않는다.
함수가 호출될 때 인수에 제공되는 값을 기록한다. 

`예) BankAccount mockAccount = createMock(BankAccount);` 
다음과 같이 목 객체를 생성하여 사용

단점으로는 테스트가 비현실적이고 중요한 버그를 잡지 못할 위험이 있다.

### 10.4.3 스텁
함수가 호출되면 미리 정해 놓은 값을 반환함으로써 함수를 시뮬레이션

### 10.4.4 목과 스텁은 문제가 될 수 있다
주요 단점
- 목이나 스텁이 실제 의존성과 다른 방식으로 동작하도록 설정되면 테스트는 실제적이지 않다.
- 구현 세부 사항과 테스트가 밀접하게 결합하여 리팩터링이 어려워질 수 있다.

### 10.4.5 페이크
페이크는 클래스의 대체 구현체로 테스트에서 안전하게 사용할 수 있다.
외부 시스템과 통신하는 대신 페이크 내의 멤버 변수에 상태를 저장한다.

페이크를 사용하면 목과 스텁에 대한 문제점을 피할 수 있다.
- 페이크로 인해 보다 실질적인 테스트가 이루어질 수 있다.
- 페이크를 사용하면 구현 세부 정보로부터 테스트를 분리할 수 있다.

## 요약
- 코드베이스에 제출된 거의 모든 '실제 코드'는 그에 해당하는 단위 테스트가 동반되어야 한다.
- '실제 코드'가 보여주는 모든 동작에 대해 이를 실행해보고 결과를 확인하는 테스트 케이스가 작성되어야 한다. 아주 간단한 테스트 케이스가 아니라면 각 테스트 케이스 코드는 준비, 실행 및 단언의 세 가지 부분으로 나누는 것이 일반적이다.
- 바람직한 단위 테스트의 주요 특징은 다음과 같다.
  - 문제가 생긴 코드의 정확한 탐지
  - 구현 세부 정보에 구애받지 않음
  - 실패가 잘 설명됨
  - 이해하기 쉬운 테스트 코드
  - 쉽고 빠르게 실행
- 테스트 더블은 의존성을 실제로 사용하는 것이 불가능하거나 현실적으로 어려울 때 단위 테스트에 사용할 수 있다.
  - 목
  - 스텁
  - 페이크
- 목 및 스텁을 사용한 테스트 코드는 비현실적이고 구현 세부 정보에 밀접하게 연결될 수 있다.
- 목과 스텁의 사용에 대한 여러 의견이 있다. 필자의 의견은 가능한 한 실제 의존성이 테스트에 사용되어야 한다는 것이다. 이렇게 할 수 없다면, 페이크가 차선책이고, 목과 스텁은 최후의 수단으로만 사용되어야 한다.
