# 10 단위 테스트의 원칙
## 목차
- [10.1 단위 테스트의 기초](#101-단위-테스트의-기초)
- [10.2 좋은 단위 테스트는 어떻게 작성할 수 있는가?](#102-좋은-단위-테스트는-어떻게-작성할-수-있는가)
- [10.3 퍼블릭 API에 집중하되 중요한 동작은 무시하지 말라](#103-퍼블릭-api에-집중하되-중요한-동작은-무시하지-말라)
- [10.4 테스트 더블](#104-테스트-더블)
- [10.5 테스트 철학으로부터 신중하게 선택하라](#105-테스트-철학으로부터-신중하게-선택하라)

## 10.1 단위 테스트의 기초
- 테스트 중인 코드: 실제 코드(프로덕션 코드)
- 테스트 코드: 단위 테스트를 구성하는 코드
- 테스트 케이스: 각 테스트 케이스는 특정 동작이나 시나리오를 테스트
   - 준비(arrange) : given -> 테스트에 필요한 값, 의존성, 인스턴스 등을 설정
   - 실행(act) : when -> 테스트 할 동작을 호출
   - 단언(assert) : then -> 실제로 올바른 동작이 실행됐는지 확인

## 10.2 좋은 단위 테스트는 어떻게 작성할 수 있는가?
### 훼손의 정확한 감지
단위 테스트의 주 목표는 "코드가 훼손되지 않았는지" 확인하는 것이다.<br>
-> 의도대로 수행되고 버그가 없는지 확인

1. 코드에 대한 초기 신뢰를 준다.
2. 미래의 훼손을 막아준다.

#### 간헐적으로 실패하는 테스트(flakey)
1. 랜덤성
2. 타이밍 기반 레이스 조건
3. 외부 시스템에 의존

훼손에 의한 실패가 아니기 때문에 원인을 찾느라 시간을 낭비할 수 있다.<br>
따라서 코드게 훼손됐을 때만 테스트가 실패해야 한다.

### 세부 구현 사항에 독립적
private 메서드를 테스트하지 않는 이유로 해석할 수 있다.

테스트 코드가 프로덕션 코드를 너무 많이 알고 있으면 수정 시 테스트 코드도 수정되어야 한다. 실수가 발생할 여지가 크다.

> 질문: "기능 변경과 리팩토링을 같이 하지 마라." <br>
나의 안 좋은 습관 중 하나인데 이를 분리하기가 쉽지 않다. 좋은 방법이 있을까?


### 잘 설명되는 실패
- 에러 메시지를 명확하게 한다.
- 하나의 테스트 케이스에 하나의 사항만 검사한다.
- 각 테스트 케이스에 대해 서술적인 이름을 사용한다.

### 이해할 수 있는 테스트 코드
다른 개발자가 이 테스트는 무엇을 테스트하고 어떻게 수행되는지 이해할 수 있어야 한다.
- 테스트 실패는 코드가 다른 방식으로 동작한다는 것이다.
- 테스트도 하나의 문서다.

### 쉽고 빠르게 실행
단위 테스트는 자주 실행된다. 느리거나 실행이 어려우면 작업 속도를 느리게 만든다.

테스트를 빠르고 쉽게 유지해야 테스트할 수 있는 기회를 극대화할 수 있다.

## 10.3 퍼블릭 API에 집중하되 중요한 동작은 무시하지 말라
ex) 캐싱을 적용했는데 다시 호출했을 때 캐시에서 꺼내 쓰는지?

퍼블릭 API 외에 기능적으로 중요한 사항들도 테스트해야 한다.

## 10.4 테스트 더블
- 테스트 단순화: 복잡한 의존성을 단순하게 만들어준다.
- 테스트로부터 외부 세계 보호: 실제 데이터베이스에 값을 쓰는 것을 막는 등 외부 시스템을 보호할 수 있다.
- 외부로부터 테스트 보호: 외부로부터 받는 의존적인 값은 시간에 따라 변경될 수 있다. 테스트 더블로 항상 동일한 값을 주도록 설정할 수 있다.

### 목(mock)
- 아무 것도 하지 않는 껍데기
- 메서드를 호출하는지 검증

### 스텁(stub)
- 호출하면 미리 정해 놓은 값을 반환

> 일상적으로 mock을 말하면 목과 스텁 둘 다 지칭한다. ex) Mockito

### 목과 스텁의 문제점
1. 실제적이지 않은 테스트를 만들 수 있다.
    - 에러가 발생해야 하는 상황인데 **목**을 사용해서 에러가 발생하지 않음
    - 10단위의 값을 반환하는 기능인데 **스텁**을 사용해서 1단위의 값을 반환함
2. 테스트가 구현 세부 정보에 유착될 수 있다.
    - 목 또는 스텁을 사용하기 위해 세부 정보를 알아야 한다.

지금까지 목과 스텁의 문제점에 대해 생각해보지 않고 사용했었다. 이러한 문제점을 인지하고 사용해야 겠다.

### 페이크(fake)
- 의존성 객체를 페이크 객체로 변경

> @FakeBean 이라는 어노테이션을 구현해서 가짜 빈을 주입하도록 구현해본적 있다<br>
질문: 페이크객체는 코드의 중복을 가져오는 것 아닌가? 프로덕션 코드가 수정되면 페이크 객체에 정의된 코드도 수정해야 하는 것 아닌가? -> 유지보수 문제

## 10.5 테스트 철학으로부터 신중하게 선택하라
우리는 여러 철학과 방법론을 자유롭게 선택할 수 있다.

어떤 철학을 따르지 않는다고 해서 그 철학의 모든 것을 무시하는 것이 아니다. 완전히 동의하지 않는 것이다.

TDD를 안 한다고 해서 테스트를 중요하게 생각하지 않는 개발자인가?<br>
우리가 코드를 작성하는 것은 어떤 문제를 해결하기 위함이다. 철학과 방법론은 하나의 "방법"일 뿐 본질적인 목적을 달성하기 위해 노력해야 한다.
