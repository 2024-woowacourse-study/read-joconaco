# 좋은 코드, 나쁜 코드 (10) 단위 테스트 원칙

date: March 10, 2024
preview: 좋은 코드, 나쁜 코드 10장을 읽고 정리한 글입니다.

---

### 💭 좋은 단위 테스트는 어떻게 작성할 수 있는가

좋은 단위 테스트가 가져야 할 기능은 다음과 같다. 

- 훼손의 정확한 감지
- 세부 구현 사항에 독립적
- 잘 설명되는 실패
- 이해할 수 있는 테스트 코드
- 쉽고 빠르게 실행

**훼손의 정확한 감지**

초기에 작성된 코드가 코드베이스에 병합되기 전에 테스트를 통해 실수를 발견할 수 있다. 또한, 코드 변경으로 인해 잘 돌아가던 기능이 동작하지 못하는 경우를 회귀라고 하는데 회귀를 탐지할 목적으로 테스트를 실행할 수 있다. 

**세부 구현 사항에 독립적**

코드베이스가 생기는 변화는 기능적 변화와 리팩터링이다. 기능적 변화가 생기면 테스트도 충분히 수정할 가능성이 높다. 리팩터링은 코드의 구조만 변경되는 것이기에 테스트가 유지되어야 한다. 하지만 테스트가 깨지는 경우는 실수로 코드의 동작을 변경했다는 의미다. 

**잘 설명되는 실패**

코드의 변경으로 테스트가 실패한다면, 문제 상황을 쉽게 파악할 수 있어야 한다. 제대로 알려주지 않는다면 그것을 알아내기 위해 많은 시간을 낭비해야 한다. 

**이해할 수 있는 테스트 코드**

너무 많은 것을 테스트하거나 너무 많은 공유 테스트 설정을 하는 경우에 이해하기 어려울 수 있다. 테스트 코드를 이해하기 쉽게 만들어야 하는 이유는 일부 개발자들은 사용설명서로 사용하기 때문이다. 

**쉽고 빠르게 실행**

단위 테스트는 매우 자주 실행된다. 테스트에 오랜 시간이 걸리면 테스트 자체가 힘든 작업이 돼버린다. 

### 💭 퍼블릭 API에 집중하되 중요한 동작은 무시하지 말라

개발자 사이에서 종종 언급되는 말이 있다. 다음은 훌륭한 조언이지만 절대적이지 않다. 

- Public API만을 이용해 테스트하라
- 실행 세부 사항을 테스트하지 말라

하지만 추상화 계층 관점에서는 한 코드가 다른 코드에 대해 알아야 할 모든 것이 퍼블릭 API로 제공되기 때문에 그 외의 모든 것은 구현 세부사항이라고 볼 수 있다. 그러나 테스트에 관해서는 퍼블릭 API로 제공되지 않는 것 중에서도 테스트 코드가 알아야 할 다른 사항들이 있을 수 있다. 예를 들어, 다음과 같은 상황이 존재한다. 

- 서버와 상호작용하는 코드
- 데이터베이스에 값을 저장하거나 읽는 코드

### 💭 테스트 더블

다른 코드에 의존성이 있는 코드를 테스트하는 방법 중 하나는 테스트 더블이다. 테스트 더블은 의존성을 시뮬레이션하는 객체지만 테스트에 더 적합하게 사용할 수 있게 만든다. 목, 스텁, 페이크 등이 있는데 페이크를 사용하는 것이 낫다.

테스트 더블을 사용하는 이유는 다음과 같다. 

- 테스트 단순화
    
    실제 의존성을 설정하거나 하위 종속성에서 무언가를 검증할 필요가 없다. 더 빠르게 테스트를 실행할 수 있다. 
    
- 테스트로부터 외부 세계 보호
    
    테스트가 실제 데이터베이스에 의존하는 경우에 데이터가 더러워지는 경우가 예시다. 
    
- 외부로부터 테스트 보호
    
    반대로 실제 데이터베이스에 의존하는 경우에 데이터의 변경으로 테스트가 깨지는 경우가 예시다. 
    

**목**

클래스나 인터페이스를 시뮬레이션하는 데 멤버 함수에 대한 호출을 기록하는 것 외에는 어떠한 일도 하지 않는다. 


**스텁**

함수가 호출되면 미리 정해 놓은 값을 반환한다. 테스트 대상 코드가 의존하는 다른 코드로부터 값을 받아와야 하는 경우에 그 의존성을 시뮬레이션하는 데 유용하다.  



하지만 목과 스텁은 문제가 될 수 있다. 

- 목이나 스텁이 실제 의존성과 다른 방식으로 동작하도록 설정되면 테스트는 실제적이지 않다.
- 구현 세부 사항과 테스트가 밀접하게 결합하여 리팩터링이 어려워질 수 있다.

**페이크**

페이크는 실제 의존성의 공개 API를 정확하게 시뮬레이션하지만 구현은 단순하고 외부와 통신하는 대신에 페이크 내의 멤버 변수에 상태를 저장한다. 요점은 코드 계약이 실제 의존성과 동일하기 때문에 실제 클래스(또는 인터페이스)가 특정 입력을 받아들이지 않는다면 페이크도 마찬가지라는 점이다. 



페이크를 사용할 때의 장점은 다음과 같다. 

- 페이크로 인해 보다 실질적인 테스트가 이루어질 수 있다.
- 페이크를 사용하면 구현 세부 정보로부터 테스트를 분리할 수 있다.

### 💭 테스트 철학으로부터 신중하게 선택하라

테스트를 둘러싼 여러 철학과 방법론이 존재한다. 

- **TDD (테스트 주도 개발)**
    
    실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성한다. 실제 코드는 테스트만 통과하도록 최소한만 작성하고 이후에 구조를 개선하고 중복을 없얘기 위한 리팩터링을 한다. 
    
- **BDD (행동 주도 개발)**
    
    이 철학의 핵심은 사용자, 고객, 비즈니스 관점에서 소프트웨어가 보여야 할 행동을 식별하는 데에 집중하는 것이다. 
    
- **ATDD (수용 테스트 주도 개발)**
    
    고객의 관점에서 소프트웨어가 보여줘야 하는 동작을 식별하고 소프트웨어가 전체적으로 필요에 따라 작동하는지 검증하기 위해 자동화된 수락 테스트를 만드는 것이다. TDD와 마찬가지로 실제 코드를 구현하기 전에 이러한 테스트를 생성해야 한다. 합격 테스트를 모두 통과하면 소프트웨어는 완전한 것이며 고객이 수락할 준비가 된 것이다. 
    

### 💭 요약

- 코드 베이스에 제출된 거의 모든 '실제 코드'는 그에 해당하는 단위 테스트가 동반되어야 한다.
- '실제 코드'가 보여주는 모든 동작에 대해 이를 실행해보고 결과를 확인하는 테스트 케이스가 작성되어야 한다. 아주 간단한 테스트 케이스가 아니라면 각 테스트 케이스 코드는 준비, 실행 및 단언의 세 가지 부분으로 나누는 것이 일반적이다.
- 바람직한 단위 테스트의 주요 특징은 다음과 같다.
    - 문제가 생긴 코드의 정확한 탐지
    - 구현 세부 정보에 구애받지 않음
    - 실패가 잘 설명됨
    - 이해하기 쉬운 테스트 코드
    - 쉽고 빠르게 실행
- 테스트 더블은 의존성을 실제로 사용하는 것이 불가능하거나 현실적으로 어려울 때 단위테스트에 사용할 수 있다. 테스트 더블의 몇 가지 예는 다음과 같다.
    - 목
    - 스텝
    - 페이크
- 목 및 스텁을 사용한 테스트 코드는 비현실적이고 구현 세부 정보에 밀접하게 연결될 수 있다.
- 목과 스텁의 사용에 대한 여러 의견이 있다. 필자의 의견은 가능한 한 실제 의존성이 테스트에 사용되어야 한다는 것이다. 이렇게 할 수 없다면, 페이크가 차선책이고, 목과 스텁은 최후의 수단으로만 사용되어야 한다.