# Chapter4 오류

오류가 눈에 띄지 않게 발생하지 않도록하고, 적절하게 처리 되도록 하기 위해 사용할 수 있는 기술을 논의 

## 4.1 복구 가능성

복구할 수 있는 오류와 복구할 수 없는 오류가 무슨 의미인지 설명

### 4.1.1 복구 가능한 오류

시스템 외부의 무언가에 의해 야기되는 오류에 대해서는 대부분 시스템 전체가 표나지 않고 적절하게 처리하기 위해 노력해야 함

예시)
- 잘못된 전화번호 입력: 사용자에게 번호가 유요하지 않다느 오류 메시지 제공, 올바른 번호 입력 요청
- 네트워크 오류: 몇 초 기다렸다가 다시 시도, 네트워크 연결 확인 요청
- 중요하지 않은 작업 오류: 서비스 사용에 대한 통계를 기록하는 부분이라면 실행을 계속해도 무방

### 4.1.2 복구할 수 없는 오류

프로그래밍 오류 때문에 발생할 때가 많음.  
합리적인 방법은 피해를 최소화하고 문제를 발견 후 해결 가능성 최대화

예시)
- 코드와 함께 추가되어야 하는 리소스가 없음
- 어떤 코드가 다른 코드를 잘못 사용
  - 잘못된 입력 인수 호출
  - 일부 필요한 상태를 사전에 초기화 안함

### 4.1.3 호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다

다음 중 하나라도 해당되는 경우, 함수에 제공된 값으로 인해 발생하는 오류는 호출하는 쪽에서 복구하고자 하는것으로 간주
- 함수가 어디서 호출될지, 호출 시 제공되는 값이 어떨지 정확한 지식이 없음
- 코드가 재사용될 가능석이 희박.

이것의 유일한 예외는 특정 입력이 무효라는 점이 코드 계약을 통해 명확함. 호출하는 쪽에서 함수를 호출하기 전에 입력을 검증하는 쉽고 분명한 방법을 가지고 있는 경우

### 4.1.4 호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라

그렇지 않으면 이 함수를 호출하는 개발자가 오류를 처리하는 코드를 작성하지 않은 상태에서 오류가 발생하는 경우 개발자의 예상과는 다른 결과를 초래할 수 있음

## 4.2 견고성 vs 실패

오류 발생 시, 다음 중 하나 선택
- 실패, 더 높은 코드 계층이 오류를 처리하게 함 or 전체 프로그램 작동 멈춤
- 오류 처리 후 계속 진행

### 4.2.1 신속하게 실패하라

신속하게 실패하기(failing fast)는 가능한 한 문제의 실제 발생 지점으로부터 가까운 곳에서 오류를 나타내는것

스택 트레이스 위치가 버그의 실제 발생 지점과 별로 상관없는 곳에서 발생한다면 이것은 문제해결에 별로 도움이 되지 않음

복구할 수 없는 오류의 경우에는 다음 절에서 설명하는 것처럼 코드가 실제로 짖을 뿐만 아니라 크게 짖는지도 확인해야함.이것은 요란한 실패(faling loudy)로 알려져있음

### 4.2.2 요란하게 실패하라

오류가 발생하는데도 불구하고 아무도 모르는 상황을 막고자 하는 것

가장 명백하고 강압적인 방법은 예외를 발생해 프로그램이 중단되게 하는 것

### 4.2.3 복구 가능성의 범위

작은 범위에서 복구할 수 없지만 서버 전체가 멈추는 것은 막을 수 있음(복구 할 수 있음)

견고하게 작성 : 한번의 잘못된 요청으로 서버가 멈추는 것은 바람직하지 않음

요란하게 실패 : 오류를 못 알아채고 계속 동작 하는 것도 바람직하지 않음

해결책
- 프로그래밍 오류가 발견할 수 있도록 오류를 기록하고 모니터링
- 적당히 견고하게 작성. 하지만 오류 발생률이 너무 높아지면 개발팀에 알림

>서버 프레임워크  
대부분 개별 요청에 대한 오류를 격리. 따라서 개발자가 직접 catch 가능성 적음.  
개념적으로 이와 유사한 일이 서버 프레임워크 내부에서 일어남

### 4.2.4 오류를 숨기지 않음

오류를 숨기는 것은 복구할 수 있는 오류, 없는 오류 모두 문제를 일으킴
- 호출 쪽에서 복구할 오류를 숨지면, 복구할 기회를 없애는 것
- 복구할 수 없는 오류 숨기면 프로그래밍 오류가 감춰짐. 이런건 개발팀이 알아야만 고침
- 두 경우 모두 예측대로 코드가 실행되지 않음. 

### 오류가 발생했다는 사실을 숨길 수 있는 몇가지 방법

기술 중 일부는 다른 상황에서 유용하지만 오류 처리에 있어서는 일반적으로 모두 바람직하지 않음.

1. 기본값 반환

- 간단하고 쉬움
- 오류가 발생했다는 사실 숨김
- 대부분 적합하지 않음. 
- 신속한 실패, 요란한 실패 원리 위반

2. 널 객체 패턴

- 기본값과 유사하지만 객체를 다룸
- 양날의 검
- 꽤 유용한 경우가 있지만 바람직하진 않음

3. 아무것도 하지 않음

- 개발자가 기대하는 것과 실제 수행 불일치
- 버그 발생 확률 높음
- 오류를 기록하는 약간 개선된 방법이 있지만 여전히 바람직하지 않음

>기록되는 내용에 주의해야 한다  
오류 기록시 개인 정보(이메일 등)가 포함되면 데이터 처리 정책에 위반될 수 있음

## 4.3 오류 전달 방법

오류를 알리는 방법 두 가지
- 명시적 방법: 오류 발생 가능성을 인지할 수밖에 없도록 함. 코드 계약의 명확한 부분이라 모르고 넘어가기 거의 불가능
- 암시적 방법: 오류를 알리지만 호출하는 쪽에서 신경쓰지 않아도 됨. 세부 조항에서 언급 할 수 있음

| | 명시적 오류 전달 기법 | 암시적 오류 전달 기법 |
| --- | --- | --- |
| 코드 계약 위치 | 명확한 부분 | 세부 조항 or 없음 |
| 호출 쪽에서 오류 발생 가능성 인지 | 앎 | 알 수도 모를 수도 있음 |
| 기법의 예 | 검사 예외 | 비 검사 예외 |
|| 널 반환 유형(널 안전성 경우) | 매직값 반환(피해야 함) |
|| 옵셔널 반환 유형 | 프로미스 or 퓨처 |
|| 리절트 반환 유형 | 어서션 |
|| 아웃컴 반환 유형(반환값 확인 필수 경우) | 체크(구현에 따라) |
|| 스위프트 오류 | 패닉 |

### 4.3.1 요약: 예외


코드에서 오류 or 예외적인 상황 발생한 경우 이를 전달하기 위한 방법.  
예외가 발생할 때 콜 스택을 거슬러 올라감  
자바만 검사, 비검사 예외 모두 가짐. 나머지는 일반적으로 비검사 예외

### 4.3.2 명시적 방법: 검사 예외

호출하는 쪽에서 예외 처리를 위한 코드 작성 or 자신의 함수 시그니처에 해당 예외발생 선언  
처리하지 않는다면 컴파일 실패함.

### 4.3.3 암시적 방법: 비검사 예외

다른 개발자가 예외 발생 사실을 모를 수 있음. 문서를 안볼 수도 문서가 업데이트가 안될 수도 있음

### 4.3.4 명시적 방법: 널값이 가능한 반환 유형

널 안정성 지원하는 경우 강제적으로 인지, 처리할 수밖에 없음. 지원하지 않는 경우 옵셔녈 반환 유형 사용 추천\\

### 4.3.5 명시적 방법: 리절트 반환 유형

널값 or 옵셔널 타입 반환은 오류 정보를 전달할 수 없음. 리절트 유형은 가능. 언어에서 지원하지 않는 경우 만들 수 있음

>리절트 유형 구현  
>러스트 및 스위프트에서 리절트 유형을 어떻게 구현하는지 살펴보면 이해하는데 도움
>- https://doc.rust-lang.org/beta/core/result/enum.Result.html
>- https://developer.apple.com/documentation/swift/result


### 4.3.6 명시적 방법: 아웃컴 반환 유형

아웃컴 반환 유형을 반환할 때 호출하는 쪽에서 반환값을 강제적으로 확인해야 한다면 이것은 오류를 알리는 명백한 방법

#### 아웃컴이 무시되지 않도록 보장

호출쪽에서 반환값 무시 or 반환하는지 모름  
일부 언어에서 반환값 무시 시 컴파일러 경고를 생성 표시
- 자바 `CheckReturnValue` 애너테이션(`javax.annotation` 패키지)
- C# `MustuseReturnValue` 애너테이션(https://www.jetbrains.com/help/resharper)
- C++ [[nodiscard]] 속성

### 4.3.7 암시적 방법: 프로미스 또는 퓨처

프로미스 or 퓨처는 비동기 함수로부터 값을 반환하는 훌륭한 방법. 오류 처리를 강제하지 않기 때문에 암시적 방법

`then()` 함수는 프로미스가 이행되면 호출되는 콜백 기능을 설정 하기위해 사용, `catch()` 함수는 프로미스가 거부되면 호출되는 콜백을 설정하기 위해 사용

리절트 유형의 프로미스를 반환하여 명시적으로 만들 수 있음. 유용하지만 복잡하다는 단점

### 4.3.8 암시적 방법: 매직값 반환

함수의 정상적인 반환 유형에 적합하지만 특별한 의미를 부여하는 값임

## 4.4 복구할 수 없는 오류의 전달

복구 가능성이 없는 오류가 발생하면 신속하고 요란하게 실패하는 것이 최상의 방법. 이를 위한 방법들
- 비검사 예외 발생
- 프로그램이 패닉이 되도록(언어가 지원하는 경우)
- 체크나 어서션 사용

### 호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달

이 주제는 일치된 의견이 없음. 관련하여 비검사 예외 vs 명시적 오류 전달 기법 논쟁이 있음

<u>먼저 기억할 점은 나와 나의 팀이 동의한 철학이 다른 어떤 주장보다 중요하다는 점</u>

### 4.5.1 비검사 예외를 사용해야 한다는 주장

#### 코드 구조 개선

대부분 오류 처리가 코드 상위 계층에서 이루어질 수 있기 때문에 코드 구조 개선 가능 주장.  
이 접근법의 핵심 장점은 오류를 처리하는 로직이 코드 전체에 퍼지지 않고 별도로 몇 개의 계층에만 있음

#### 개발자들이 무엇을 할 것인지에 대해서 실용적이어야 함

너무 많은 명시적 오류를 접하면 스트레스에 결국 잘못된 일(예외 무시 등)을 한다고 주장

### 4.5.2 명시적 기법을 사용해야 한다는 주장

#### 매끄러운 오류 처리

오률 매끄럽게 처리할 단일 계층 갖기 어려움.

예시로 단순 사용자 입력 잘못되면 입력 필드 바로 옆 오류 메시지 출력이 타당. 오류가 더 높은 수준 전달 후 사용자 친화적이지 않은 오류 메시지 출력하게됨

#### 실수로 오류를 무시할 수 없다

일부러 무시하면 코드 검수 시 명확하게 드러나고, 잘못된 코드 차단 가능성 커짐

#### 개발자들이 무엇을 할 것인지에 대해서 실용적이어야 함

비검사 예외가 잘 문서화된다는 보장 없음.

모든 예외를 아우르는 예외를 처리하는 것은 바람직하지 않음. 거의 모든 유형의 오류가 숨겨짐.

>표준 예외 유형 고수  
ArgumentException이나 StateException과 같은 표준 예외 유형 or 그들의 서브클래스를 사용하는 것.  
개발자들은 이런 표준 예외들이 발생할 것이라고 예측, 적절하게 처리함으로써 신경써야할 예외의 종류가 줄어듬.

### 4.5.3 필자의 의견: 명시적 방식을 사용하라

필자는 복구를 원하는 오류는 비검사 예외를 사용하지 않는 것이 최상 주장.
- 비검사 예외 완전히 문서화 경우 매우 드뭄.
  - 그렇기에 발생 가능 오류와 처리를 알기 불가능
  - 이런 경우 많은 버그, 작동 실패를 경험

최악은 팀 내 각자 개발자들이 서로 다른 접근 방식을 사용하는 것

## 4.6 컴파일러 경고를 무시하지 말라

코드가 의심스러우면 경고 표시, 버그 조기 경고 가능성

컴파일러 경고를 오류로 여기고 컴파일 안되게 설정 가능. 엄격하지만 매우 유용

## 요약

- 오류 두 가지
  - 시스템 복구 가능 오류
  - 시스템 복구 불가능 오류

- 복구 가능 여부는 코드를 호출하는 쪽에서만 알 경우 많음

- 에러 발생하면 신속 실패, 에러 복구 불가능 경우 요란하게 실패

- 오류 전달 기법 두 범주
  - 명시적 방법: 코드 계약 명확한 부분. 오류 인지할 수밖에 없음
  - 암시적 방법: 세부 조항 부분.

- 복구할 수 없는 오류는 암시적 오류 전달 기법 사용

- 잠재적 복구 가능한 오류에 대해 필자는 명시적 기법 추천

- 컴파일러 경고 기울이면 유용함
