# 4. 오류

<!-- TOC -->

* [4. 오류](#4-오류)
    * [4.1 복구 가능성](#41-복구-가능성)
        * [복구 가능한 오류](#복구-가능한-오류)
        * [복구할 수 없는 오류](#복구할-수-없는-오류)
        * [호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다.](#호출하는-쪽에서만-오류-복구-가능-여부를-알-때가-많다)
        * [호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 해라](#호출하는-쪽에서-복구하고자-하는-오류에-대해-인지하도록-해라)
    * [4.2 견고성 vs 실패](#42-견고성-vs-실패)
        * [신속하게 실패하라(failing fast)](#신속하게-실패하라failing-fast)
        * [요란하게 실패하라(failing loudly)](#요란하게-실패하라failing-loudly)
        * [복구 가능성의 범위](#복구-가능성의-범위)
        * [오류를 숨기지 않음](#오류를-숨기지-않음)
    * [4.3 오류 전달 방법](#43-오류-전달-방법)
        * [명시적 방법](#명시적-방법)
        * [암시적 방법](#암시적-방법)
    * [4.4 복구할 수 없는 오류의 전달](#44-복구할-수-없는-오류의-전달)
    * [4.5 호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달](#45-호출하는-쪽에서-복구하기를-원할-수도-있는-오류의-전달)
        * [비검사 예외를 사용해야 한다는 주장](#비검사-예외를-사용해야-한다는-주장)
        * [명시적 기법을 사용해야 한다는 주장](#명시적-기법을-사용해야-한다는-주장)
    * [4.6 컴파일러 경고를 무시하지 말라](#46-컴파일러-경고를-무시하지-말라)

<!-- TOC -->

## 4.1 복구 가능성

- 오류는 복구 가능 여부에 따라 `복구 가능 오류`와 `복구 불가능 오류`로 분류할 수 있다.
- 오류가 발생할 때 무엇을 할 것인지 결정하기 위해서는 자신의 코드가 어떻게 사용될지 신중하게 생각해야 한다.

### 복구 가능한 오류

- 복구 가능한 오류는 치명적이지 않으며, 오류가 발생하더라도 사용자가 알아채지 못하도록 적절하게 처리할 수 있는 오류를 의미한다.
    - ex) 네트워크 오류, 중요하지 않은 작업 오류

### 복구할 수 없는 오류

- 오류가 발생하고 시스템이 오류를 복구할 수 있는 합리적인 방법이 없는 경우이다.
- 복구하기 어려우면, 피해를 최소화하고 개발자가 문제를 발견하고 해결할 가능성을 최대화해야 한다.

### 호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다.

**(결론) 해당 코드에 의해 생성된 오류로부터 복구할 수 있는지 여부를 해당 코드를 호출하는 쪽에서 알 수 있는 경우가 많다.**

### 호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 해라

- 함수를 호출하는 개발자가 오류를 처리하는 코드를 작성하지 않은 상태에서 오류가 발생하는 경우, 개발자의 예상과는 다른 결과를 초래할 수 있다.
- 이로 인해 버그가 발생하거나, 중요한 비즈니스 로직에서 오류가 발생할 수 있다.
- 함수에서 오류가 발생할 수 있다는 것을 함수를 호출하는 쪽에서 알 수 있게 하는 방법은 아래 내용에서 계속 다룬다.

## 4.2 견고성 vs 실패

- 오류가 발생할 경우, 다음 중 하나를 선택해야 한다.
    - 더 높은 코드 계층이 오류를 처리하게 하거나 전체 프로그램의 작동을 멈추게 한다.
    - 오류를 처리하고 계속 진행
- 오류가 있더라도 처리하고 계속 진행하면 더 견고한 코드라고 볼 수 있지만, 오류가 감지되지 않고 이상한 일이 발생하기 시작한다는 의미도 될 수 있다.

### 신속하게 실패하라(failing fast)

- `신속하게 실패하기`는 가능한 한 문제의 실제 발생 지점으로부터 가까운 곳에서 오류를 나타내는 것이다.
- 오류가 발생했을 때 신속하게 실패하지 않으면, 오류는 실제 위치에서 멀리 떨어진 코드에서 나타날 수 있다.(추적 어려움)

### 요란하게 실패하라(failing loudly)

- `요란하게 실패하기`는 오류가 발생하는데도 불구하고 아무도 모르는 상황을 막고자 하는 것이다.
- 이를 위한 가장 명백한(그리고 강압적인) 방법은 예외를 발생해 프로그램이 중단되게 하는 것이다.

**(결론) 에러가 발생하면 신속하게 실패하는 것이 좋고, 에러를 복구할 수 없는 경우에는 요란하게 실패하는 것이 바람직하다.**

### 복구 가능성의 범위

- 클라이언트의 요청에 대한 오류는 요청을 처리하는 범위 내에서 복구할 수 있는 합리적인 방법은 존재하지 않는다.
- 하지만, 시스템 전체가 작동을 멈추는 것은 막을 수 있다.
- 즉, 이 경우에는 해당 요청 범위 내에서 복구할 수 없지만, 서버 전체적으로 복구할 수 있다.

**(결론) 복구할 수 있는 또는 복구할 수 없는 범위는 달라질 수 있다.**

### 오류를 숨기지 않음

- 오류를 감추면 호출하는 쪽에서 모든 것이 잘 작동하고 있다고 가정하지만, 실제로 코드는 제대로 동작하지 않을 수 있다.
- 아래는 일부 다른 상황에서는 유용하지만 오류 처리에 있어서 일반적으로 바람직하지 않은 방법이다.(오류를 숨기는 방법들)
    - 기본값 반환
    - 널 객체 패턴
    - 아무것도 하지 않음

## 4.3 오류 전달 방법

- 오류가 발생하면 일반적으로 더 높은 계층으로 오류를 알려야 한다.
- 오류를 알리는 방법은 크게 두 가지 종류가 있다.
    - `명시적 방법` : 코드를 직접 호출한 쪽에서 오류가 발생할 수 있음을 인지할 수밖에 없도록 한다.
    - `암시적 방법` : 코드를 호출하는 쪽에 오류를 알리지만, 호출하는 쪽에서 그 오류를 신경 쓰지 않아도 된다.
- 요란하게 실패할지 말지에 대한 것이 아닌 오류 발생 가능성이 명시적인지 암시적인지에 대한 이야기이다.

### 명시적 방법

- 검사 예외
- 널 반환 유형
- 옵셔널 반환 유형
- 리절트 반환 유형
- 아웃컴 반환 유형
- 스위프트 오류

### 암시적 방법

- 비검사 예외
- 매직값 반환(피해야 함!)
- 프로미스 또는 퓨처
- 어서션
- 체크
- 패닉

## 4.4 복구할 수 없는 오류의 전달

- 복구하기 어려운 오류가 발생하면 신속하게 실패하고, 요란하게 실패하는 것이 최상의 방법이다.
- 복구하기 어려운 오류에 대해서는 `암시적 오류 전달 기법`을 사용해야 한다.
- 자신이 호출한 쪽에 오류 전달하는 거 말고 뭘할 수 있는데 ㅋㅋ

## 4.5 호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달

> 팀이 동의한 철학이 다른 어떤 주장보다도 중요하다.

### 비검사 예외를 사용해야 한다는 주장

- `코드 구조 개선` : 대부분의 오류 처리가 코드의 상위 계층에서 이루어질 수 있기 때문에 비검사 예외를 발생시키면 코드 구조를 개선 가능하다.(오류 처리 로직이 코드 전체에 퍼지지 않음)
- `실용적 접근` : 검사 예외를 사용하면 호출 체인을 따라 이전 호출자에게 명시적으로 오류를 전달해야 하므로 연쇄적인 코드 수정이 발생한다. 따라서 개발자는 검사 예외를 중간에 숨겨버리는 선택을 할 수 있다.

### 명시적 기법을 사용해야 한다는 주장

- `매끄러운 오류 처리` : 비검사 예외를 사용하면 모든 오류를 매끄럽게 처리할 수 있는 단일 계층을 갖기 어렵다.
- `실수로 오류를 무시할 수 없음`
- `실용적 접근` : 비검사 예외가 코드베이스 전반에 걸쳐 제대로 문서화된다는 보장이 없다.(catch 문에서 Exception으로 전부 캐치하는 것이 바람직한가?)

## 4.6 컴파일러 경고를 무시하지 말라

- 컴파일러 경고에 주의를 기울이면 코드베이스에 병합되기 훨씬 전에 코드로부터 프로그래밍 오류를 발견하고 제거할 수 있다.
- 컴파일러 경고를 오류로 여기고 코드가 컴파일되지 않도록 설정하는 것은 유용하다.
- 특정 경고만 억제할 수 있는 방법이 존재한다. (자바에서는 @SuppressWarning 애노테이션을 사용해서 경고 무시 가능)
