# 7. 코드를 오용하기 어렵게 만들라

<!-- TOC -->

* [7. 코드를 오용하기 어렵게 만들라](#7-코드를-오용하기-어렵게-만들라)
    * [7.1 불변 객체로 만드는 것을 고려하라](#71-불변-객체로-만드는-것을-고려하라)
        * [가변 클래스는 오용하기 쉽다.](#가변-클래스는-오용하기-쉽다)
    * [7.2 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라](#72-객체를-깊은-수준까지-불변적으로-만드는-것을-고려하라)
        * [깊은 가변성은 오용을 초래할 수 있다.](#깊은-가변성은-오용을-초래할-수-있다)
    * [7.3 지나치게 일반적인 데이터 유형을 피하라](#73-지나치게-일반적인-데이터-유형을-피하라)
        * [지나치게 일반적인 유형은 오용될 수 있다.](#지나치게-일반적인-유형은-오용될-수-있다)
    * [7.4 시간 처리](#74-시간-처리)
    * [7.5 데이터에 대해 진실의 원천을 하나만 가져야 한다.](#75-데이터에-대해-진실의-원천을-하나만-가져야-한다)
        * [또 다른 진실의 원천은 유효하지 않은 상태를 초래할 수 있다.](#또-다른-진실의-원천은-유효하지-않은-상태를-초래할-수-있다)
    * [7.6 논리에 대한 진실의 원천을 하나만 가져야 한다.](#76-논리에-대한-진실의-원천을-하나만-가져야-한다)

<!-- TOC -->

## 7.1 불변 객체로 만드는 것을 고려하라

- 객체가 생성된 후에 상태를 바꿀 수 없다면 이 객체는 `불변(immutable)`이라 한다.
- 그 반대인 `가변(mutability)` 객체는 추론하기 어려우며, 다중 스레드에서 문제가 발생할 수 있다.
- 매번 불변이 적절하거나 항상 가능한 것은 아니다. 기본으로 불변을 지향하고 필요한 곳에서만 가변을 사용하자.

### 가변 클래스는 오용하기 쉽다.

- 클래스를 가변으로 만드는 가장 일반적인 방법은 setter를 제공하는 것이다.
- setter를 제공하면 오용하기 좋아진다.(오용으로부터 스스로 방어할 수 있어야 한다.)
- 객체를 생성할 때만 값을 할당해 불변적으로 만들고, 오용도 방지할 수 있다.
- 불변 클래스의 가변 버전을 만들어야 하는 경우, 불변성에 대한 디자인 패턴을 사용할 수 있다.
    - `빌더 패턴(값을 설정하기 위해 빌더 클래스는 가변적임)`
    - `쓰기 시 복사 패턴`

## 7.2 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라

- 클래스가 실수로 가변적으로 될 수 있는 일반적인 경우는 `깊은 가변성(deep mutability)` 때문이다.
- 깊은 가변성은 멤버 변수 자체가 가변적인 유형이고 다른 코드가 멤버 변수에 액세스할 수 있는 경우 발생한다.

### 깊은 가변성은 오용을 초래할 수 있다.

- 방어적 복사로 해결할 수 있다. ex) `List.copyOf()`
    - 단점 : 복사 비용 문제가 존재하고, 클래스 내부에서 발생하는 변경을 막아주지 못하는 경우가 존재한다.
- 또 다른 해결 방법으로 불변적 자료구조를 사용할 수 있다. ex) `Guava의 ImmutableList`
- 불변적 자료구조를 사용하면 어차피 수정이 불가하기 때문에 어디든 날아다녀도 무관하고, 방어적 복사도 필요 없다.

## 7.3 지나치게 일반적인 데이터 유형을 피하라

**일반적이고 다재다능하다는 것을 뒤집어 생각해보면 데이터 유형 자체만으로는 무언가를 설명할 수 없고, 가질 수 있는 값에 있어서도 꽤 관대하다는 것을 의미한다. ex) 정수, 문자열, 리스트**

### 지나치게 일반적인 유형은 오용될 수 있다.

- 지나치게 일반적인 데이터 유형은 설명을 위해 약간 복잡한 문서를 필요로 할 수 있다. 유형 자체로 아무것도 설명해주지 않기 때문이다.
- 형식 안정성이 거의 없다. 코드가 정상적으로 컴파일되지만, 런타임에 문제가 발생할 수 있다.
- 패러다임은 퍼지기 쉽다.

**(결론) 만들기 귀찮아도 전용 유형을 정의하자. 코드가 훨씬 더 명확해지고 오용하기 어렵기 때문에 중장기적으로 시간 절약 효과가 있다.**

## 7.4 시간 처리

- 정수로 시간을 나타내는 것은 문제가 될 수 있다.(정수는 매우 일반적인 유형)

**(결론) 시간을 다루는 것은 복잡하고 까다로운 일이며 혼란의 여지가 많다. 사용하는 언어에 가장 적합한 라이브러리를 찾기 위해 노력을 기울이자.**

## 7.5 데이터에 대해 진실의 원천을 하나만 가져야 한다.

- 코드에서 숫자, 문자열, 바이트 스트림과 같은 종류의 데이터를 처리하는 경우가 많은데, 데이터는 종종 두 가지 형태로 제공된다.
    - `기본 데이터(primary data)` : 코드에 제공해야 할 데이터. 코드에 이 데이터를 알려주지 않고는 코드가 처리할 방법이 없다. ex) `대변, 차변`
    - `파생 데이터(derived data)` : 주어진 기본 데이터에 기반해서 코드가 계산할 수 있는 데이터 ex) `계좌 잔액`
- 기본 데이터는 일반적으로 프로그램에서 `진실의 원천(source of truth)`이 된다.

### 또 다른 진실의 원천은 유효하지 않은 상태를 초래할 수 있다.

- 기본 데이터와 파생 데이터를 모두 처리하는 코드를 작성할 때, 유효하지 않은 상태가 발생할 수 있다. ex) `대변, 차변, 잔액을 생성자에서 받음`
- 이를 해결하기 위해서는 기본 데이터를 유일한 진실의 원천으로 사용해야 한다.
- 만약, 파생된 값을 계산하는 데 많은 비용이 든다면, 값을 지연 계산한 이후에 결과를 캐싱하는 것이 좋다.

## 7.6 논리에 대한 진실의 원천을 하나만 가져야 한다.

- 진실의 원천은 코드에 제공된 데이터에만 제공되는 것이 아닌, 코드에 포함된 논리에도 적용된다.
- 논리에 대한 진실의 원천이 여러 개 있으면 버그를 유발할 수 있다.
- 논리에 대한 진실의 원천이 두 개가 있는 상태에서 개발자가 하나만 수정하면 문제가 발생하기 쉽다.
- 따라서, 진실의 원천은 단 하나만 있어야 한다.
