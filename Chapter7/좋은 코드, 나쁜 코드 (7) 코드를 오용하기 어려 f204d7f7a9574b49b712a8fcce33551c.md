# 좋은 코드, 나쁜 코드 (7) 코드를 오용하기 어렵게 만들라

date: February 28, 2024
updatedAt: March 3, 2024 11:10 PM
tags: 📖 Review
status: Done
preview: 좋은 코드, 나쁜 코드 7장을 읽고 정리한 글입니다.

---

우리가 작성하는 코드는 훨씬 더 큰 소프트웨어의 일부일 뿐이다. 서로 다른 코드가 올바르게 작동하기 위해선 오용하기 어려운 코드를 작성해야 한다. 오용될 수 있는 몇 가지 사례는 다음과 같다. 

- 호출하는 쪽에서 잘못된 입력을 제공
- 다른 코드의 부수 효과(입력 매개변수의 수정 등)
- 정확한 시간이나 순서에 따라 함수를 호출하지 않음
- 관련 코드에서 가정과 맞지 않게 수정이 이루어짐

### 💭 불변 객체로 만드는 것을 고려하라

가변 객체를 지양해야 하는 근거는 다음과 같다. 

- 가변 객체는 추론하기 어렵다. 생성 시점과 현재 상태가 다를 수 있기 때문이다.
- 가변 객체는 다중 스레드에서 문제가 발생할 수 있다. 한 스레드가 해당 객체를 읽는 도중에 다른 스레드가 상태를 변경할 여지가 있다.
- 가변 객체를 전달 받는 모든 코드는 오용의 가능성이 생긴다.

이를 해결하는 방법은 생성할 때만 값을 할당하여 불변 객체로 만드는 것이다. `final` 등의 키워드로 생성 이후에 객체의 상태가 변하지 않도록 한다. setter가 존재한다면 당연히 삭제한다. 

그럼, 객체의 상태에 수정이 필요한 경우는 어떻게 해야 할까? 불변성에 대한 디자인 패턴을 사용하는 것이 좋다. 예시로 빌더 패턴이나 복사 패턴이 있다. 

**빌더 패턴**

클래스의 생성자로 모든 필드의 값을 세팅하는 데에는 비용이 발생한다. 일부 필드의 값이 선택 사항이라면 번거로운 일이다. 빌더 패턴은 한 클래스를 두 개로 나누는 효과를 갖는다. 

- 값을 하나씩 설정할 수 있는 빌더 클래스
- 빌더에 의해 작성된 불변적인 읽기 전용 클래스

빌더 패턴을 통해 도메인 객체는 불변성을 유지하는 반면, 빌더 클래스는 생성자와 setter를 갖는 가변 객체이다. 

**쓰기 시 복사 패턴**

setter와 비슷하지만, 객체의 상태를 변경하는 것이 아니라 변경된 상태를 갖는 인스턴스를 생성하여 반환한다. 다음은 `TextOptions` 클래스의 내부 메서드이다. 

![스크린샷 2024-03-03 오후 9.59.40.png](%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3,%20%E1%84%82%E1%85%A1%E1%84%88%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%20(7)%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%A9%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A5%E1%84%85%E1%85%A7%20f204d7f7a9574b49b712a8fcce33551c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-03-03_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.59.40.png)

![스크린샷 2024-03-03 오후 10.00.05.png](%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3,%20%E1%84%82%E1%85%A1%E1%84%88%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%20(7)%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%A9%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A5%E1%84%85%E1%85%A7%20f204d7f7a9574b49b712a8fcce33551c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-03-03_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.00.05.png)

### 💭 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라

다음 코드에서 `fontFamily` 변수는 `List<Font>` 인스턴스의 참조 값을 갖고 있다. `getFontFamily()`를 호출하면 이 참조 값을 반환한다. 

![스크린샷 2024-03-03 오후 10.01.46.png](%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3,%20%E1%84%82%E1%85%A1%E1%84%88%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%20(7)%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%A9%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A5%E1%84%85%E1%85%A7%20f204d7f7a9574b49b712a8fcce33551c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-03-03_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.01.46.png)

위 클래스에서 `fontFamily`의 상태는 불변하다. 하지만 `fontFamily`가 참조하는 인스턴스의 내부는 가변적이다. 이를 해결하는 방법은 방어적 복사이다. 

![스크린샷 2024-03-03 오후 10.05.22.png](%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3,%20%E1%84%82%E1%85%A1%E1%84%88%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%20(7)%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%A9%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A5%E1%84%85%E1%85%A7%20f204d7f7a9574b49b712a8fcce33551c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-03-03_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.05.22.png)

방어적 복사는 불변적인 클래스를 만들 수 있지만, 단점이 명확하다. 

- 복사하는 비용이 많이 들 수 있다. `fontFamily`에 수백개의 글꼴이 있다면 `getFontFamily()`가 호출될 때마다 많은 비용이 발생할 것이다.
- 깊은 불변성을 제공하지 못한다. 외부에 제공하는 경우에 복사하는 것이지, 내부적으로 변경가능하다.

이를 해결하는 방법은 애초에 불변 자료구조를 사용하는 것이다. 

![스크린샷 2024-03-03 오후 10.09.09.png](%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3,%20%E1%84%82%E1%85%A1%E1%84%88%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%20(7)%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%A9%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A5%E1%84%85%E1%85%A7%20f204d7f7a9574b49b712a8fcce33551c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-03-03_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.09.09.png)

### 💭 지나치게 일반적인 데이터 유형을 피하라

지구상의 좌표를 저장하는 자료 구조로 Double을 사용한다면 다음과 같을 것이다. 

![스크린샷 2024-03-03 오후 10.10.22.png](%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3,%20%E1%84%82%E1%85%A1%E1%84%88%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%20(7)%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%A9%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A5%E1%84%85%E1%85%A7%20f204d7f7a9574b49b712a8fcce33551c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-03-03_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.10.22.png)

List와 Double은 너무 일반적인 자료구조이다. 이렇게 하면 코드를 오용하기 쉽고 이를 방지하기 위해 설명하기 시작하면, 그 코드는 가독성이 좋지 않은 코드의 증거다. 

- 위도와 경도의 순서를 바꿀 수 있다.
- 형식에 대한 안정성이 없다. 값이 존재하지 않을 수도 있다.

주의해야 할 점은 패러다임은 퍼지기 쉽다는 점이다. 

개발 과정에서 좌표를 표현하기 위해 임시로 일반적인 자료구조를 사용했다고 가정하자. 이 패러다임은 이 좌표를 사용하는 다른 모든 클래스에게 전파된다. 모든 클래스는 좌표를 다루기 위해 일반적인 자료구조를 사용하고 문서화된다. 단지 하나의 자료구조로 인해 전체 코드베이스가 영향을 받게 되는 것이다. 

이를 해결하기 위한 방법으로 Pair를 떠올리기 쉽다. 하지만 Pair 역시 내부적으로 Interger, Double 같은 일반적인 자료구조를 사용하기에 오용하기 쉽다. 

가장 좋은 방법은 해당 도메인에 대한 객체를 생성하는 것이다. 이 객체를 통해 코드의 오용 가능성은 낮아지고, 더이상 추가적인 문서화가 필요 없어졌다. 

![스크린샷 2024-03-03 오후 10.16.00.png](%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3,%20%E1%84%82%E1%85%A1%E1%84%88%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%20(7)%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%A9%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A5%E1%84%85%E1%85%A7%20f204d7f7a9574b49b712a8fcce33551c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-03-03_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.16.00.png)

### 💭 시간 처리

코드에서 시간을 처리하는 경우에 고려해야 할 점이 상당히 많다. 

- 표현하는 시간은 크게 2가지 종류가 있다. "어느 한 시점"과 "시간의 양" 이다.
- 시간의 단위는 다양하다. 밀리초, 초, 분, 시, 일 …
- 시간대 처리도 중요한 문제이다.

이 문제를 해결하는 방법도 적절한 자료구조를 사용하는 것이다. 자바에서는 java.time 패키지를 제공한다. java.util 패키지도 시간과 관련한 클래스를 제공하지만 가변성으로 인해 사용하지 않도록 권고하고 있다. 

### 💭 데이터에 대해 진실의 원천을 하나만 가져야 한다

원천에 대해 다음 예시를 보면 쉽게 이해할 수 있다. 

![스크린샷 2024-03-03 오후 10.22.02.png](%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3,%20%E1%84%82%E1%85%A1%E1%84%88%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%20(7)%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%A9%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A5%E1%84%85%E1%85%A7%20f204d7f7a9574b49b712a8fcce33551c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-03-03_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.22.02.png)

`balance`는 `credit-debit`이다. 하지만 생성자에서 이 공식과 다른 값이 입력될 수 있다. 이를 해결하는 방법은 데이터의 원천을 하나로 두는 것이다. 즉 `blance`는 제공하지 않고 `credit`과 `debit`으로 `blance`를 계산하는 것이다. 

하지만 이 방식이 문제가 되는 지점이 있는데, 계산 비용이 많이 드는 경우이다. 파생된 값을 계산하는 데에 많은 비용이 발생한다면, 그 계산을 지연(lazy)하는 것도 하나의 방법이다. 지연한다는 것의 의미는 값을 실제로 사용하는 시점에 연산을 진행한다는 의미이다. 

![스크린샷 2024-03-03 오후 10.25.38.png](%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3,%20%E1%84%82%E1%85%A1%E1%84%88%E1%85%B3%E1%86%AB%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%20(7)%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%A9%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A5%E1%84%85%E1%85%A7%20f204d7f7a9574b49b712a8fcce33551c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-03-03_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.25.38.png)

### 💭 요약

- 코드가 오용되기 쉽게 작성되고 나면 어느 시점에선가는 오용될 가능성이 크고 이것은 버그로 이어질 수 있다.
- 코드가 오용되는 몇 가지 일반적인 사례는 다음과 같다.
    - 호출하는 쪽에서 잘못된 입력을 제공
    - 다른코드에서 일어나는 부수 효과
    - 함수 호출 시점이 잘못되거나 올바른 순서로 호출되지 않은 경우
    - 원래의 코드에 연관된 코드를 수정할 때 원래의 코드가 내포한 가정과 어긋나게 수정하는 경우
- 오용이 어렵거나 불가능하도록 코드를 설계하고 구조화하는 것이 종종 가능하다. 이를 통해 버그 발생 가능성이 크게 줄어들고 중장기적으로 개발자의 시간을 많이 절약할 수 있다.