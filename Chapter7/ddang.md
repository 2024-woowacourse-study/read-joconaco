# Ch7. 코드를 오용하기 어렵게 만들라

## 7.1 불변 객체로 만드는 것을 고려하라

- 객체가 생성된 후에 상태를 바꿀 수 없다면 이 객체는 불변
- 가변 객체는 추론하기 어려움
  - 불변 객체는 객체를 여기저기 전달하더라도 어디서도 그 객체가 변경됐거나 무언가 추가되지 않았다는 것을 확신할 수 있음
- 가변 객체는 다중 스레드에서 문제가 발생할 수 있음
  - 한 스레드가 객체를 읽는 동안 다른 스레드가 그 객체를 수정하는 경우 오류 발생 가능
- 가변 객체는 코드 복잡성을 늘리고 문제를 일으킬 수 있으므로, 기본적으로 불변적인 객체를 만들되 필요한 곳에서만 가변적이 되도록 하는 것이 바람직
- 가변 클래스는 오용하기 쉬움
  - 가장 일반적인 방법인 setter를 사용하는 경우, 해당 인스턴스를 전달받는 모든 코드는 이 객체를 변경할 수 있기 때문에 오용의 위험성이 있음

### 객체를 생성할 때만 값을 할당하라

- 모든 값이 객체 생성 시에 제공되고, 이후로는 변경할 수 없도록 함으로써 클래스를 불변으로 만들 수 있고 오용도 방지할 수 있음
- 클래스 내부에서도 변수의 값이 변경되지 않도록 final 키워드 사용
  - 실수로라도 변경하는 것을 방지하고, 변경되지도, 변경되어서도 안된다는 점을 분명하게 함

### 불변성에 대한 디자인 패턴을 사용하라

- 빌더 패턴
  - 값의 일부 또는 전체가 선택 사항일 때 객체를 만드는 유용한 방법
  - 한 클래스를 두 개의 형태로 나눠줌
    - 값을 하나씩 설정할 수 있는 빌더 클래스
    - 빌더에 의해 작성된 불변적인 읽기 전용 클래스
  - 필수 멤버는 생성자의 입력 매개변수를 통해 받고, 필수적이지 않은 값은 빌더의 세터 함수를 통해 받음
  - 값을 설정하기 위해 빌더 클래스는 가변적이고, build() 메서드를 호출하면 클래스의 불변 인스턴스를 반환
- 쓰기 시 복사 패턴

## 7.2 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라

- 멤버 변수 자체가 가변적인 유형이고, 다른 코드가 멤버 변수에 엑세스 할 수 있는 경우
  - 리스트와 같이 멤버 변수로 참조를 가지는 경우
  - 다른 코드에서 같은 참조를 가지는 경우, 변경될 수 있음

### 방어적을 복사하라

- 클래스가 참조하는 객체가 클래스 외부의 코드에서는 참조할 수 없도록 막음
  - 클래스가 생성될 때와 getter를 통해 객체가 반환될 때 객체의 복사본을 만들면 됨
  - 복사하는데 비용이 많이 들 수 있음

## 7.3 지나치게 일반적인 데이터 유형을 피하라

- 데이터 유형 자체만으로는 무언가를 설명할 수 없고, 가질 수 있는 값에 대해서도 관대함
- 어떤 값을 나타내는지 알 수 없고, 파라미터 입력 순서를 혼동할 수 있음

### 전용 유형 사용

- 무언가를 나타내기 위해 새로운 클래스를 정의
- 코드가 명확해지고 오용하기 어려워짐

## 7.5 데이터에 대해 진실의 원천을 하나만 가져야 한다

- 기본 데이터: 코드에 제공해야 할 데이터
  - 은행의 대변과 차변
- 파생 데이터: 기본 데이터에 기반해 코드가 계산할 수 있는 데이터
  - 계좌 잔고 (대변 - 차변)
    - 기본 데이터로 계산 가능

### 기본 데이터를 유일한 진실의 원천으로 사용하라

- 기본 데이터와 파생 데이터를 모두 처리하는 코드를 작성할 때, 논리적으로 잘못된 상태가 발생할 수 있음
  - 기본 데이터와 파생 데이터가 모두 주어지면 중복 정보 -> 논리적으로 잘못된 상태를 유발할 수 있음
- 파생 데이터는 기본 데이터만 가지고 완전히 계산할 수 있기 때문에 필요할 때에만 값을 계산하는 것이 나음

## 7.6 논리에 대한 진실의 원천을 하나만 가져야 한다

- 제공된 데이터 뿐만 아니라 논리에 대해서도 같은 원리 적용
