# 3 다른 개발자와 코드 계약
## 목차
- [3.1 자신의 코드와 다른 개발자의 코드](#31-자신의-코드와-다른-개발자의-코드)
    - [3.1.1 자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다](#311-자신에게-분명하다고-해서-다른-사람에게도-분명한-것은-아니다)
    - [3.1.2 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다](#312-다른-개발자는-무의식중에-여러분의-코드를-망가뜨릴-수-있다)
    - [3.1.3 시간이 지나면 자신의 코드를 기억하지 못한다](#313-시간이-지나면-자신의-코드를-기억하지-못한다)
- [3.2  여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?](#32-여러분이-작성한-코드의-사용법을-다른-사람들은-어떻게-아는가)
- [3.3 코드 계약](#33-코드-계약)
    - [3.3.1 계약의 세부 조항](#331-계약의-세부-조항)
    - [3.3.2 세부 조항에 너무 의존하지 말라](#332-세부-조항에-너무-의존하지-말라)
- [3.4 체크 및 어서션](#34-체크-및-어서션)
    - [3.4.1 체크](#341-체크)
    - [3.4.2 어서션](#342-어서션)

## 3.1 자신의 코드와 다른 개발자의 코드
나의 코드는 독립적이지 않고 다른 코드를 의존하거나 다른 코드에 의존되고, 다른 개발자에 의해 재사용된다. 또한 요구 사항은 항상 변하기 때문에 나의 코드는 다른 개발자에 의해 변경된다.<br>

### 3.1.1 자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다
내가 작성한 코드는 익숙해서 왜 그렇게 구현했는지 분명하다. 그러나 다른 개발자에 의해 내 코드가 변경될 때 나의 의도와 다른 방향으로 변경될 수 있다. 그들에게는 분명하지 않기 때문이다. <br>
따라서 이것을 항상 고려하고, 코드의 How, What, Why가 분명하도록 작성해야 한다.

### 3.1.2 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다
다른 개발자가 내 코드를 수정할 때 잘못된 방식으로 수정할 가능성이 크다 (사전 지식이 적기 때문에)<br>
따라서 문제가 있을 때 컴파일이 중지되거나 테스트가 실패하도록 만드는 신뢰 장치가 필요하다.

### 3.1.3 시간이 지나면 자신의 코드를 기억하지 못한다
1 ~ 2년이 지난 내 코드는 다른 사람이 작성한 코드를 보는 것과 크게 다르지 않다. 따라서 이해하기 쉽고 버그가 발생하기 어렵도록 코드를 작성해야 한다.

## 3.2 여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?
코드를 사용하려면 그 코드가 무슨 일을 하는지 파악해야 한다. 사용법을 알기 위해서 5가지 방식을 사용할 수 있다.

1. 이름 확인
    - 이름을 잘 짓는 것이 중요하다.
2. 데이터 유형 확인
    - 데이터 유형으로 코드를 오용하거나 오작동을 예방한다.
3. 문서 읽기
    - 다른 개발자가 읽을 것이라는 보장이 없다. 
4. 직접 물어보기
    - 작성자가 자리에 없다면? 작성자가 코드를 기억하지 못한다면?
5. 코드 세부 구현 살펴보기
    - 코드의 양이 많으면 효과없다.

추상화 계층으로 몇 가지의 개념으로만 사용할 수 있어야 한다.

## 3.3 코드 계약
코드 사용을 계약으로 본다.

### 3.3.1 계약의 세부 조항
계약의 모든 약관을 주의 깊게 읽는가? 코드도 마찬가지다.

- 계약의 명확한 부분
    - 함수, 클래스명
    - 파라미터
    - 리턴 타입
    - Checked Exception
- 세부 사항
    - 주석 또는 문서
    - Unchecked Exception

명확한 부분을 더욱 명확하게 드러내고 세부 사항을 적게 사용한다.

### 3.3.2 세부 조항에 너무 의존하지 말라
주석이나 문서는 읽지 않고 넘어갈 때가 많다. 문서에 의존해야 할 상황이라면 다른 개발자가 반드시 읽도록 해야 한다.

## 3.4 체크 및 어서션
런타임 때 검사하는 방식이다. 컴파일 타임 때 확인할 수 없는 경우에 사용한다.

### 3.4.1 체크
- 전제 조건 검사
- 사후 상태 검사

### 3.4.2 어서션
체크와 유사하지만 빌드할 때 컴파일에서 제외된다. 따라서 코드가 실제 서비스 환경에서 사용될 때는 실패를 보여주지 않는다.
- 성능 향상
- 코드 오류 발생률을 낮춤
