## Chapter3 다른 개발자와 코드 계약

- 다른 개발자들이 코드와 어떻게 상호작용하는지
- 코드 계약과 코드 계약의 세부 조항
- 세부 조항을 최소화하는 것이 어떻게 오용, 예측을 벗어나는 코드를 예방하는데 도움이 되는지
- 세부 조항을 피할 수 없다면 체크와 어서션을 어떻게 사용항 수 있는지

혼자 개발하지 않고 팀 단위로 개발하는 것이 현실. 서로 다른 개발자가 작성한 코드를 작업해야 함

- 이 장에서 코드의 중요한 세부사항을 다른 개발자에게 전달하기 위한 여러가지 기법에 대해 논의  
- 코드 계약 및 숨겨진 세부조항(small print)의 개념을 사용해 이 내용을 형식화  
- 이 장의 마지막 두 절에서는 오용과 오해를 쉽게 유발하는 코드의 실제 사례를 살펴 보고 코드를 개선하는 방법을 논의

<details>
  <summary>3.1 자신의 코드와 다른 개발자의 코드</summary>
  팀 일원으로 코드 작성 -> 이를 바탕으로 계층 쌓음 -> 다른 개발자가 하위 문제 해결 코드 재사용.


  요수 사항은 항상 변함
  - 우선순위 변경
  - 새로운 기능 추가
  - 시스템을 새로운 기술 환경으로 이동

  많은 개발자들이 코드를 수정하는데 잘못된 코드라면 문제 생기기 쉬움

  고품질 코드 작성시 가장 중요한 고려 사항
  - 다른 개발자가 변경 or 상호작용 시 발생할 문제가 있는지, 발생하면 어떻게 완화할지 선제적 조치

  코드 작성 시 다음 세 가지 고려하는 것이 유용
  1. 자신에게 명백하다고 해서 다른 사람에게도 명백한 것이 아님
  2. 다른 개발자가 무의식중에 내 코드를 망가뜨릴 수 있음
  3. 시간이 지남에 따라 내 코드도 기억 못함

  <details>
    <summary>3.1.1 자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다</summary>

    문제 해결을 위해 여러 단계를 거치며 몇 시간 혹 며칠을 보내기 때문에 나는 로직이 익숙함.  
    
    하지만 남이 내 코드를 사용 or 변경 or 내 코드가 의존하는 코드 변경 등 상황이 있고 남은 익숙하지 않음

    주석문 많이 작성 한다는 의미가 아니라 코드 자체로 설명 되게 하는 것이 좋은 방법.
  </details>

  <details>
    <summary>3.1.2 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다</summary>

    코드는 여러 다른 코드에 의존, 그 코드는 또 다른 코드에 의존  
    기능 추가 및 리팩터링하며 그런 코드들이 계속 변함

    문제가 있으면 코드 병합히면 안되기 때문에 뭔가 문제가 있을 때  
    1. 컴파일 중지 
    2. 테스트 실패하도록 만들기

  </details>

  <details>
    <summary>3.1.3 시간이 지나면 자신의 코드를 기억하지 못한다</summary>

    시간이 지난 후 새로운 기능 추가 or 발견된 버그 해결 시 기억이 안남

    좋은 코드 작성은 미래의 자신에게도 유익

  </details>
</details>

<details>
  <summary>3.2 여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?</summary>
  
  구체적으로 그들은 다음과 같은 사항을 이해할 필요가 있음
  - 여러 가지 상황에서 어떤 함수를 호출해야 하는지
  - 클래스가 무엇을 나타내는지 그리고 언제 사용되어야 하는지
  - 어떤값을 인수로 사용해야 하는지
  - 코드가 수행하는 동작이 무엇인지
  - 어떤 값을 반환하는지

  코드 사용법을 알아내는 방법
  - 함수, 클래스, 열거형 등의 이름을 살펴
  - 함수와 생성자의 매개변수 유형 또는 반환값의 유형 같은 데이터유형을 살펴봄
  - 함수/클래스 수준의 문서나 주석문을 읽어본다.
  - 직접 와서 묻거나 채팅/이메일을 통해 문의
  - 여러분이 작성한 함수와 클래스의 자세한 구현 코드를 읽음

  이 중 처음 세 가지 만이 실제로 사용, 그 중 처음 두 가지가 더 신뢰할 만함

  <details>
    <summary>3.2.1 이름 확인</summary>

    패키지, 클래스, 함수의 이름을 책의 목차라고 생각 할 수 있음. 하위 문제를 해결할 코드를 찾기 편리하고 빠름
    따라서 코드를 어떻게 사용해야 하는지이 대해 가장 잘 전달할 수 있는 방법 중 하나는 이름을 잘 짓는 것

  </details>

  <details>
    <summary>3.2.2 데이터 유형 확인</summary>

    컴파일이 필요한 정적 유형의 언어에서는 타입을 인식하고 올바르게 사용하지 않으면 컴파일되지 않음  
    따라서 타입을 사용하는 언어로 작성하는 것은 코드를 오용, 오작동할 수 없도록 하기 위한 좋은 방법

  </details>

  <details>
    <summary>3.2.3 문서 읽기</summary>

    문서는 다음과 같은 형태로 존재 가능
    - 함수 및 클래스 수준의 비공식적인 주석문
    - 자바독과 같은 좀 더 공식적인 코드 내 문서
    - 외부 문서(README.md, 웹 페이지, 지침 문서 등)

    유용하지만 어느정도 까지만 신뢰할 수 있음. 그 이유로
    - 다른 개발자가 이 문서들을 읽을 것이라는 보장 없고 실제로 않읽음
    - 읽어도 잘못 해석할 수 있음. 익숙하지 않은 용어 사용하거나 다른 개발자들의 수준에 대해 잘못된 가정 바탕으로 작성한다면
    - 문서의 업데이트가 제대로 안될 수 있음. 코드 변경 마다 업데이트를 잊어버리면 문서가 더 이상 유효하지 않음

  </details>

  <details>
    <summary>3.2.4 직접 물어보기</summary>

    코드를 작성한 지 얼마 안됐으면 상당히 효과적. 하지만 다음 이유로 신뢰하기 어려움
    - 코드를 많이 작성할수록 답하는데 많은 시간 사용
    - 작성자가 휴가 간다면 못 물어봄
    - 1년이 지나면 작성자도 기억 못함
    - 작성자가 회사를 떠나면 못 물어봄

  </details>

  <details>
    <summary>3.2.5 코드를 살펴보는 것</summary>

    가장 확실한 답을 얻을 수 있는 방법임  
    하지만 실용적이지 않고 코드 양이 많으면 효과 얻기 힘듬. 의존하는 모든 코드의 구현을 본다면 수천 줄을 읽어야함  

    추상화 계층을 만드는 요점은 개발자가 한 번에 몇 가지 개념만 처리해야 하고, 어떻게 동작하는지 정확히 몰라도 하위 문제 해결책으로 사용할 수 있어야 함. 코드 구현을 본다면 이는 이 이점을 부정하는 것

  </details>

</details>

<details>
  <summary>3.3 코드계약</summary>
  
  계약에 의한 프로그래밍(programming by contract) 또는 계약에 의한 디자인(designbycontract)
  이 원칙은 이전 절에서 논의한 개념들 중 일부를 공식화 함  
  이 철학에서는 서로 다른 코드 간의 상호작용을 마치 계약처럼 생각함  

  코드 계약에 대한 용어를 다음 세 가지 범주로 나누면 유용
  - 선결 조건(precondition): 코드 호출 전 사실이어야 하는 것. 
    예시) 시스템이 어떤 상태에 있어야함, 코드에 어떤 입력을 공급해야 함
  - 사후 조건(postcondition): 코드 호출 후 사실이어야 하는 것
    예시) 시스템이 새로운 상태에 놓임, 반환되는 값
  - 불변 사항(invariant): 코드 호출 전후 시스템 상태를 비교해서 변경되지 않아야 하는 사항

  입력 매개변수 있는 함수 작성, 값 반환, 어떤 상태를 수정  
  -> 곧 계약을 생성한 것, 그 이유는  
  - 코드 호출할 사람에게 설정 or 입력(선결 조겅)을 제공해야 할 요건 부여  
  - 호출 결과 일어날 일 or 반환될 값(사루 조건)에 대한 기대

  코드 작성 시, 만들어질 계약 내용을 생각하는 것이 중요

  <details>
  <summary>3.3.1 계약의 세부 조항</summary>

  ---
  예시) 스쿠터 렌탈앱 계약으로 명백한 사항과 숨겨진 세부 조항 살펴보기
  
  회원 가입 -> 신용카드 번호 입력 -> 가까운 스쿠터 찾기 -> 예약 -> 타고나면 -> 렌탈 종료

  | 스쿠터 렌탈 |
  | --- |
  | 시간당 $10 |
  | 예약을 클릭하면 이용 약관에 동의하는 것 |
  | 예약 |

  명백한 사항
  - 전기 스쿠터를 빌림
  - 임대로는 시간당 10달러
  
  계약 세부 조항(약관 링크를 본다면)
  1. 충돌 사고 시 수리 비용 지불
  2. 시 경계를 넘으면 벌금 부과
  3. 시속 48km를 넘으면 벌금 (스쿠터 모터 손상 문제)

  3번 항목은 예상치 못한 내용일 가능성 큼

  ---

  코드 계약 시
  
  명확한 부분 (컴파일 되지 않음)
  - 클래스, 함수 이름
  - 인자 유형
  - 반환 유형
  - 검사 예외(checked exception)

  세부 조항
  - 주석문과 문서: 모두 읽어봐야 하지만 잘 안읽음. 이를 실용적 관점에서 봐야 함
  - 비검사 예외(unchecked exception): 어떤 때는 세부 조항에 나와있지 않은 경우도 있음

  조건을 명백히 하는 것이 세부 조항을 사용하는 것보다 훨씬 나음

  </details>

  <details>
  <summary>3.3.2 세부 조항에 너무 의존하지 말라</summary>

  세부 조항에 너무 의존하면 오용하기 쉬운 취약한 코드 될 가능성 크고, 예상과 다르게 동작하기 쉬움

  그럼에도 나쁜 코드를 의존하게 된다면 문서를 작성하고 읽도록 해야함. 그래도 안읽어서 이상적인 방법은 아님

  명확하지 않을 수도 있는 사항들을 문서화하는 것은 일반적으로 좋은 생각이지만, 너무 많이 의존하지 않는 것이 최선의 방법

  <details>
  <summary>세부 조항을 제거하는 방법</summary>

  스쿠터 예시에서 30마일 넘으면 벌금이 아니라 넘는 속도를 불가능하게 만드는 것이 더 좋을 것  
  -> 30마일 세부 조항이 제거되고, 스쿠터 모터 손상 문제도 해결

  코드도 동일한 원리 적용 가능  
  세부 조항 문제 발생 -> 명백한 한목으로 변환
  코드의 상태, 인자, 반환 타입 등 신중하게 생각하면 가능할 때가 있음  
  컴파일 조차 되지 않도록 하는 것이 목표

  예시에서 private 생성자, 정적 팩토리 사용. 차이점으로 팩토리에서 널 리턴 가능. 잘못된 상태의 인스턴스 생성을 불가능하게 만듬  
  상태(state)나 가변성(mutability)이 클래스 외부로 노출되는 것음 없애는 기법 사용

  > 상태와 가변성?  
  상태는 객체가 담고 있는 값이나 데이터를 말함. 객체 생성 후 수정할 수 있으면 가변적이라 함. 반대라면 불변적이라고 함

  </details>

  </details>

</details>

<details>
<summary>3.4 체크및어서션</summary>

컴파일러를 사용하여 명백히 하는 것에 대안으로 런타임 검사 사용 가능  
컴파일 타임 확인 보단 약함, 런타임 테스트에 의존하기 때문

  <details>
  <summary>3.4.1 체크</summary>

  코드 계약이 준수되었는지 확인하기 위한 추가 로직을 말함  
  준수되지 않을 경우 체크는 실패를 유발하는 오류를 생성, 명백한 실패라 넘어가는 것 불가능

  예시) 전기 스쿠터 펌웨어에 속도 제한 추가. 이는 체크 추가와 유사

  체크는 시행 중인 계약 조건에 따라 다음과 같은 범주로 구분
  - 전제 조건 검사: 입력 인수 올바른지, 초기화 수행 유무, 코드 실행 전 시스템이 유효한 상태인지 확인 등
  - 사후 상태 검사: 반환값 올바른지, 코드 실행 후 시스템이 유효한 상태인지 확인 등

  예시로 상태가 잘못 되면 예외 발생시키는 방법  
  하지만 오용을 불가능하게 만든 해결책보다는 이상적이지 못함

  > 프로그래밍 언어에서 체크  
  예시로 stateException을 사용하여 전제 조건 검사를 구현.  
  언어에 따라 다양한 방식이 있으므로 체크를 구현하는 가장 좋은 방법 찾아야함

  체크 사용 시 기대하는 것은 고객 배포, 프로덕션 서비스 전에 개발 or 테스트 단계에서 발견 후 수정  
  하지만 보장되는 것은 아님
  - 테스트하기 불분명 상황에서만 조건 위반시, 배포 전까지 버그 노출 안될 수 있음
  - 체크가 잘 작동해도 프로그램 상위 수준에서 예외 처리(작동을 완전히 멈추지 않기 위해) 후 로그 기록시, 로그들을 신경 쓰지 않는 다면 못 알아챔

  코드에 체크가 많다면 세부 조항을 없애는 것에 고려할 신호일 수 있음

  >퍼즈 테스트 (fuzz test)
  퍼즈 테스트는 코드나 소프트웨어의 버그나 잘못된 설정을 드러낼 수 있는 입력값을 생성해 테스트를 수행하는 한 종류  
  퍼즈 테스트를 사용하는 경우, 체크(또는 어서션)를 함께 사용하면 잘못된 설정이나 버그를 발견할 가능성을 높이는데 도움.  
  왜냐하면 퍼즈 테스트는 오류나 예외 발생에 의존하며 이것만으로는 단순히 이상한 동작을 초래하는 미묘한 버그를 발견할 수 없기 때문

  </details>

  <details>
  <summary>3.4.2 어서션</summary>

  어서션(assertion)은 코드계약을 준수하도록 강제하기 위한 방법이라는 점에서 체크와 매우 유사
  
  어서션과 체크 주요 차이점 : 배포를 위해 빌드할 때 어서션은 보통 컴파일에서 제외  
  이는 코드가 실제 서비스 환경에서 사용될 때 실패를 명백하게 보여주지 않는다는 것을 의미  
  코드를 배포할 때 컴파일 하지 않는 이유는 다음과 같음
  - 성능 향상: 조건 위반 확인 시, CPU 사이클 필요. 많은 어설션 -> 성능 저하
  - 오류 발생률 낮추기: 중요도가 (버그 발생 가능성 방지 < 고가용성) 이라면 제외 하는 것은 적절한 절충

  </details>

</details>

### 요약

- 코드베이스는 계속 변하고 일반적으로 여러 개발자에 의해 변경됨
- 다른 개발자가 어떻게 코드를 해석하고 오용할 수 있을지 생각, 이러한 가능성을 최소화 or 오용 불가능하게 만드는 방식으로 코드 작성이 유용
- 코드를 작성할 때 일종의 코드 계약이 항상 만들어짐. 명백한 항목과 세부 조항 같은내용이 포함될 수 있음
- 코드 계약 세부 조항은 다른 개발자가 계약을 준수하도록 하기위한 방법이지만 신뢰할만한 방법은 아님. 보통 더 나은 접근법은 명백한 항목으로 계약 내용 전달
- 일반적으로 컴파일러를 사용하여 계약을 확인하는 것이 가장 신뢰할 수 있는 방법. 이것이 불가능할 때, 체크 or 어서션 사용하여 실행시간에 계약을 확인
