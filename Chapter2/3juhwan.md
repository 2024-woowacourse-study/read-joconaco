### 💭 추상화 계층이란 무엇인가?

추상화 계층은 특정한 집합의 기능의 자세한 부분을 숨기는 한 방법이다. 추상화 계층을 하는 이유는 문제를 쉽게 해결하기 위해서이다. 문제가 엄청나게 복잡할지라도 하위 문제들을 식별하고 올바른 추상화 계층을 만듦으로써 그 복잡한 문제를 쉽게 다룰 수 있다.

아래 예시는 HTTP로 서버에 메시지를 전송하는 예제다. HTTP로 서버에 메시지를 전송하는 문제를 추상화 계층을 만듦으로써 수많은 하위 문제로 나누었다.

![스크린샷 2024-02-25 오후 4.44.56.png](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fefb36dfc-2d55-48d0-8f77-b8907ee88d56%2F847ccfe3-faa2-4819-9f2b-9c847eda328b%2F%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-02-25_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.44.56.png?table=block&id=c06669f2-65f9-4994-9e56-e8229d80e779&spaceId=efb36dfc-2d55-48d0-8f77-b8907ee88d56&width=2000&userId=16dd7b3c-70e6-4cea-8e84-44ad8b396ed4&cache=v2)


HTTP를 통해 서버로 메시지를 전송하는 문제는 3개의 하위 문제를 통해 해결할 수 있다. 하단에 존재하는 문제들은 모르더라도 상위 문제를 푸는 데에 지장을 주지 않는다. 이를 통해 개발자는 해결해야 하는 문제에 집중할 수 있다.

### 💭 추상화 계층으로 코드 품질은 어떻게 개선되는가?

**가독성**

개발자는 하위 몇 개의 계층만 다루면 된다. 위 HTTP를 통해 서버로 메시지를 전송하는 문제에서 개발자가 다룰 문제는 하위 문제 3개 (문자열 메시지 보내기, HTTP 연결 열기, HTTP 연결 닫기)에 불과하다.

**모듈화**

추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부사항이 외부로 노출되지 않도록 보장할 때, 다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내에서만 구현을 변경하기가 매우 쉬워진다.

**재사용성 및 일반화성**

하위 문제에 대한 해결책이 간결한 추상화 계층으로 제시되면 해당 하위문제에 대한 해결책을 재사용하기가 쉬워진다. 또한, 다른 상황에서도 사용될 수 있도록 일반화되기 쉽다.

**테스트 용이성**

추상화 계층이 깔끔하게 나눠지면 문제를 해결하기 위한 각 하위 문제를 테스트하기 쉽고 신뢰할 수 있다.

### 💭 추상화 계층을 만드는 방법

코드를 서로 다른 단위로 분할하여 단위 간의 의존 관계를 보여주는 의존성 그래프를 생성한다. 이때 사용할 수 있는 개념은 다음과 같다.

- 함수
- 클래스
- 인터페이스
- 패키지, 네임스페이스, 모듈

![스크린샷 2024-02-25 오후 4.44.56.png](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fefb36dfc-2d55-48d0-8f77-b8907ee88d56%2F4f3b22aa-493d-4469-870a-ed7865b6d74c%2F%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-02-25_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.10.48.png?table=block&id=db03c094-fe1f-4149-aa65-e8b431424a11&spaceId=efb36dfc-2d55-48d0-8f77-b8907ee88d56&width=2000&userId=16dd7b3c-70e6-4cea-8e84-44ad8b396ed4&cache=v2)

### 💭 추상화 계층을 만드는 방법: **함수**

각 함수에 포함된 코드가 하나의 잘 써진 짧은 문장처럼 읽히면 이상적이다.

- 단일 업무 수행
- 잘 명명된 다른 함수를 호출해서 더 복잡한 동작 구성

### 💭 추상화 계층을 만드는 방법: 클래스

단일 클래스의 이상적인 크기에 대한 기준은 다음과 같다.

- 한 클래스는 오직 한 가지 일에만 관심을 가져야 한다.
- 클래스는 응집력이 있어야 한다.

**응집력**

한 클래스 내의 모든 요소들이 얼마나 잘 속해 있는지를 보여주는 척도. 좋은 클래스는 매우 응집력이 강하다.

- 순차적 응집력
    - 한 요소의 출력이 다른 요소에 대한 입력으로 필요할 때 발생한다.
- 기능적 응집력
    - 몇 가지 요소들이 모여서 하나의 일을 성취하는데 기여할 때 발생한다.

**관심사의 분리**

시스템이 각각 별개의 문제(또는 관심사)를 다루는 개별 구성 요소로 분리되어야 하는 설계 원칙이다.

### 💭 추상화 계층을 만드는 방법: 인터페이스

어떤 함수를 외부로 노출할 것인지를 인터페이스를 통해 결정할 수 있다.

인터페이스의 장점

- 퍼블릭 API를 매우 명확하게 보여준다.
- 계층 사이를 뚜렷이 구분할 수 있다.
- 구현 세부 사항이 계층 사이에 유출되지 않는다.
- 테스트를 쉽게 할 수 있다.
- 같은 클래스로 두가지 하위 문제를 해결할 수 있다.

인터페이스의 단점

- 분리를 위해 더 많은 작업이 필요하다.
- 코드가 복잡해질 수 있다.
    - 인터페이스에만 의존하면 런타임에 어떤 구현체를 사용하는지 파악하기 어려움

### 💭 추상화 계층이 너무 얇아지면?

다음과 같은 추가 비용이 발생한다.

- 코드의 양이 늘어난다.
    - 클래스를 정의해야 해서
    - 의존성을 새 파일로 임포트해야 해서
    - 반복적으로 사용하는 코드(boilerplate code)로 인해
- 로직의 이해를 위해 파일이나 클래스를 따라갈 때 더 많은 노력이 필요하다.
    - 인터페이스 뒤에 계층을 숨기게 되면 어떤 상황에서 어떤 구현이 사용되는지 파악하는데 더 많
      은 노력이 필요하다.
    - 로직을 이해하기 어렵다.
    - 디버깅하는 것이 어려워질 수 있다.

### 💭 요약

- 코드를 깨끗하고 뚜렷한 추상화 계층으로 세분화하면 가독성, 모듈화, 재사용, 일반화 및 테스트 용이성이 향상된다.
- 특정 언어에 국한된 기능뿐만 아니라 함수, 클래스 및 인터페이스를 사용하여 코드를 추상화 계층으로 나눌 수있다.
- 코드를 추상화 계층으로 분류하는 방법을 결정하려면 해결 중인 문제에 대한 판단과 지식을 사용해야 한다.
- 너무 비대한 계층 때문에 발생하는 문제는 너무 얇은 계층 때문에 발생하는 문제보다 더 심각하다. 확실하지 않은 경우에는 남용의 위험에도 불구하고 계층을 얇게 만드는 것이 좋다.
