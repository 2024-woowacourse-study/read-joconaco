# Ch2. 추상화 계층

## 주요 키워드
- 가독성
- 모듈화
- 재사용성 및 일반화성
- 테스트 용이성

## 2.2 추상화 계층을 만드는 이유
- 코드 작성은 복잡한 분제를 더 작은 문제로 세분화 하는 작업
  - 문제가 아무리 복잡하더라도 올바른 추상화 계층을 만듦으로써 복잡한 문제를 쉽게 다룰 수 있음
  - 각 계층을 적절히 추상화 하면 상위 계층은 하위 계층의 동작 원리에 대해 알 필요가 없음

### 2.2.1 추상화 계층 및 코드 품질의 핵심 요소
- **가독성**
  - 개발자가 코드의 모든 세부사항을 이해하기는 어렵지만, 몇 가지 높은 계층의 추상화를 이해하고 사용하기는 쉬움 
  - 깨끗하고 뚜렷한 추상화 계층을 만들면 개발자가 한 번에 한두개 정도의 추상화 계층만 다루면 된다는 것을 의미
- **모듈화**
  - 구현 세부사항이 외부로 노출되지 않도록 보장
  - 다른 계층에 영향을 미치지 않고, 해당 계층 내에서만 구현을 변경하기 쉬워짐
    - 상위 계층에서는 이러한 변화에 대처하기 위해 특별한 작업을 수행할 필요가 없음
- **재사용성 및 일반화성**
  - 문제가 적절히 추상적인 하위 문제로 세분화되면, 해결책은 여러가지 다른 상황에서 유용하게 일반화 될 수 있음
    - 예) TCP/IP 및 네트워크 연결 처리 시스템은 웹소켓과 같은 다른 유형의 연결에 필요한 하위 문제를 해결하는데도 사용될 수 있음
- **테스트 용이성**
  - 각 하위 문제에 대한 해결책을 테스트하기 쉬워짐

## 2.3 코드의 계층
- 실제로 추상화 계층을 생성하기 위해서는 코드를 서로 다른 단위로 분할
  - 추상화 계층 생성에 사용할 수 있는 코드의 단위
    - 함수
    - 클래스
    - 인터페이스
    - 패키지, 네임스페이스, 모듈
  - 코드의 단위는 다른 단위에 의존함
  - 코드를 작성할 때, 우리가 작성한 코드를 다른 코드들이 사용할 수 있도록 미니 API를 노출하는 것으로 생각
    - 서비스를 사용할 때 알아야 하는 것들에 대한 개념을 형식화하고, 세부 구현 사항은 감춤
      - 코드를 API 관점에서 생각하면, 추상화 계층을 명확하게 만드는데 도움이 됨

### 함수
- 각 함수에 포함된 코드가 하나의 잘 써진 짧은 문장처럼 읽히면 이상적
- 단일 함수 내에서 너무 많은 작업을 수행하지 않도록 해야함
- 함수를 작게 만드는 것의 이점
  - 코드의 가독성이 좋아짐
  - 로직을 쉽게 재사용할 수 있음
    - 같은 클래스 내에서 재사용하거나, 헬퍼 클래스로 옮기고 퍼블릭 메서드로 변경할 수 있음

### 클래스
- **응집력**
  - 한 클래스 내의 요소들이 얼마나 잘 속해 있는지 보여주는 척도
  - 좋은 클래스는 응집력이 강함
  - 분류
    - 순차적 응집력
      - 한 요소의 출력이 다른 요소에 대한 입력으로 필요할 때 발생
    - 기능적 응집력
      - 몇가지 요소들이 모여 하나의 일을 성취하는 데 기여할 때 발생
- **관심사의 분리**
  - 시스템은 각각 별개의 문제를 다루는 개별 구성 요소로 분리되어야 함
  - 요구사항 변경 시 변경 지점을 최소화할 수 있음
- **응집력과 관심사의 분리 달성시 얻는 이점**
  - 코드 가독성
    - 단일 클래스에 담긴 개념이 많을수록 클래스의 가독성을 저하되고, 이해하는데 걸리는 시간이 많아지며 코드를 잘못 이해할 가능성이 커짐
  - 코드 모듈화
    - 하위 문제에 대한 해결책이 하나의 클래스로 구현되어 있다면, 구현체를 교체해야 할 때 쉽게 교체할 수 있음
  - 코드 재사용성 및 일반화
    - 다른 누군가 하위 문제를 해결해야 할 때 재사용할 수 있음
  - 테스트 용이성 및 적절한 테스트
    - 로직이 여러 클래스로 나누어지면 각 부분을 테스트하기 용이함
- 품질이 낮은 코드 개선법
  - 각 하위 문제에 대한 해결책을 자체 클래스로 분할
  - 분할한 클래스는 생성자의 매개변수를 통해 **의존성을 주입**받도록 하여 개선

### 인터페이스
- 계층 사이를 구분하고, 구현 세부 사항이 계층 사이에 유출되지 않도록 하기 위해 사용
  - 상위 계층은 인터페이스에 의존할 뿐, 로직을 구현한 클래스에 의존하지 않음
  - 구현 클래스를 쉽게 교체할 수 있음
- **주어진 하위 문제에 대해 두 가지 이상의 다른 방식으로 구현**을 해야하거나, **향후 다르게 구현할 것으로 예상되는 경우** 인터페이스 정의
- **인터페이스를 통해 얻는 이점**
  - 퍼블릭 API를 명확히 보여줄 수 있음
    - 사용해야 하는 기능과 사용하지 말아야 하는 기능의 혼동을 없앨 수 있음 
    - 구현 클래스에 퍼블릭 함수를 추가해도 상위 계층은 인터페이스에만 의존하기 때문에 해당 함수는 노출되지 않음
  - 테스트를 쉽게 할 수 있음
    - 복잡한 구현 클래스는 mock이나 페이크 객체로 대체할 수 있음

### 층이 너무 얇아질 때
- 코드를 별개의 계층으로 세분화할 때 장점이 많지만 추가 비용도 발생함
  - 반복적으로 사용하는 보일러 플레이트 코드로 인해 코드의 양이 많아짐
  - 로직의 이해를 위해 파일을 따라갈 때 더 많은 노력 필요
  - 인터페이스 뒤에 계층을 숨기면 어떤 상황에 어떤 구현이 사용되는지 파악하는데 노력 필요 (불필요한 복잡성 증가)
- 이익보다 비용이 커질 수 있으므로 적절한 수준에서 계층을 나눠야 함