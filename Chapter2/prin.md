# 2 추상화 계층
## 목차
- [2.1 널값 및 의사코드 규약](#21-널값-및-의사코드-규약)
- [2.2 왜 추상화 계층을 만드는가?](#22-왜-추상화-계층을-만드는가)
- [2.3 코드의 계층](#23-코드의-계층)
    - [2.3.1 API 및 구현 세부 사항](#231-api-및-구현-세부-사항)
    - [2.3.2 함수](#232-함수)
    - [2.3.3 클래스](#233-클래스)
    - [2.3.4 인터페이스](#234-인터페이스)
    - [2.3.5 층이 너무 얇아질 때](#235-층이-너무-얇아질-때)

## 2.1 널값 및 의사코드 규약
많은 프로그래밍 언어에서 값이 없다는 개념을 표현하기 위해 `null`을 사용한다.
그러나 널값을 제대로 처리하지 않으면 NPE(Null Pointer Exception)와 같은 오류가 발생할 수 있다.

사용하는 언어에서 널 안정성을 지원하면 그것을 사용하고, 지원하지 않으면 `Optional` 타입을 사용한다.

## 2.2 왜 추상화 계층을 만드는가?
간결한 추상화 계층은 상위 수준의 문제를 해결하기 위해 몇 가지 개념만 알면 된다는 것을 의미한다.

서버로 메시지 보내기<br>
"서버와 연결 -> 메시지 전송 -> 연결 닫기"
로 추상화할 수 있고, 각각의 하위 문제는 어떻게 구현되어 있는지 알 필요없다.

### 2.2.1 추상화 계층 및 코드 품질의 핵심 요소
1. 가독성
2. 모듈화
3. 재사용성 및 일반화성
4. 테스트 용이성

## 2.3 코드의 계층
### 2.3.1 API 및 구현 세부 사항
어떤 인터페이스를 노출해서 외부에서 사용할 수 있게 할 것인가?<br>
필요한 부분만 노출하고 구현 세부 사항은 캡슐화한다.

### 2.3.2 함수
- 단일 업무 수행 -> 한 가지 일만 하도록 한다.
- 잘 명명된 다른 함수를 호출해서 더 복잡한 동작 구성 -> 다른 객체와 상호작용할 경우 객체에게 메시지를 보낸다. (getter로 꺼내쓰지 않는다)

### 2.3.3 클래스
이상적인 클래스의 크기
- 라인 수: 300줄이 클래스의 크고 작음을 나눌 수 있는 기준은 아니지만 라인 수가 많으면 분리할 필요가 있다.
- 응집력: 좋은 클래스는 응집력이 강하다.
- 관심사의 분리: 시스템은 각각 별개의 문제를 다루는 개별 구성 요소로 분리되어야 한다.

클래스가 커지면 4가지 [핵심 요소](#221-추상화-계층-및-코드-품질의-핵심-요소)와 반대되는 결과를 얻는다.

### 2.3.4 인터페이스
어떤 함수를 외부로 노출할 것인지 인터페이스를 통해 결정한다.<br/>
두 가지 이상의 다른 방식으로 구현하거나 다르게 구현할 것으로 예상될 경우 인터페이스를 정의하는 것이 좋다.

그렇다면 인터페이스를 항상 정의하는 것이 좋을까?
```java
public interface XXService {
    void 메서드();
}

public class XXServiceImpl {
    @Override
    public void 메서드() {
        // ...
    }
}
```
구현체가 하나뿐이고 앞으로도 추가 구현체가 생길 여지가 없는 경우에도 인터페이스가 필요할까?

#### 장점
- public API를 명확하게 보여준다.
- 한 가지 구현만 필요하다고 잘못 추측한 것일 수 있다.
- 테스트를 쉽게 할 수 있다.
- 같은 클래스로 두 가지 하위 문제를 해결할 수 있다.

#### 단점
- 더 많은 작업이 필요하다.
- 코드가 복잡해질 수 있다.
- 관리해야 할 클래스가 늘어난다.

### 2.3.5 층이 너무 얇아질 때
클래스를 분리할 때 발생하는 **추가 비용**
1. 보일러플레이트 코드(ex. equals, toString, getter, setter 등)가 늘어난다.
2. 클래스 추적에 더 많은 노력이 필요하다.
3. 어떤 구현이 사용되는지 파악하는데 시간이 걸린다.

"분할을 위한 분할은 의미 없다."<br>
불필요하지 않게 적당한 수준에서 분할해야 한다.
