## Chapter 2 추상화 계층

<details>
<summary>2.1 널값 및 의사코드 규약</summary>
코드를 잘 구성한다는 것은 간결한 추상화 계층을 만드는 것으로 귀결될 때가 많음
이 장에서 이것이 무엇을 의미하는지 설명,
문제를 추상화 계층으로 나누고,
나눠진 추상화 계층을 반영하도록 코드를 구성하는 방법을 살펴봄

의사코드 예제에서 어떻게 널값을 다루는지 설명

널값은 유용하면서 동시에 문제가 많음

- '값이 없다' 또는 '부재한다'는 이 개념은 유용
- 변수 액세스 전 널값 확인을 자주 잊어버림

#### 널 안정성

널 안전성?으로 컴파일러는 반드시 널값 여부를 확인하게 만듦

- 사용 중인 언어가 널 안정성을 지원한다면 사용하는 것이 좋음
- 지원하지 않는다면, 옵셔녈(Optional) 타입을 사용하는 것이 좋음

#### 의사코드 규약

이 책에서 사용되는 의사코드는 널 안전성이 있다고 가정

##### 널 안정성 지원

데이터 유형 이름의 끝에'?' 기호가 붙어 있으면 널값을 가질 수 있다는 의미
이때 널값 여부를 확인하지 않고서는 사용할 수 없도록 컴파일러가 강제

`Element? getFifthElement (List‹Element> elements)`

##### 널 안정성 지원 X

Optional 타입을 사용
`Optional<Element> getFifthElement(List<Element> elements)`

</details>

<details>
<summary>
2.2 왜 추상화 계층을 만드는가?
</summary>
코드작성은 복잡한 문제를 계속해서 더 작은 하위문제로 세분화하는 작업

예시 - 사용자의 장치에서 실행되면서 서버에 메시지를 보내는 코드 작성

```
HttpConnection connection =
  HttpConnection.connect("http://example.com/server");
connection.send("Hello server");
connection.close ();
```

단 세 줄이며, 서버의 URL, 연결, 메시지 보내기, 연결 닫기 개념만 다루면 됨

하지만 이를 보내는데 다음과 같은 복잡한 일이 발생

- 전송 형식으로 문자열 직렬화
- HTTP 프로토콜의 모든 동작
- TCP 연결
- 데이터를 라디오 신호로 변조

등등 이 예는 서버에 메시지를 보낸다는 상위 수준의 문제가 존재  
다행히도 해결해야 할 많은 하위 문제를 다른 개발자들이 이미 해결 뿐 아니라 인식할 필요도 없게 만듬

최상위 계층에서는 하위 계층을 몰라도 코드 작성 가능  
이런 하위 계층을 추상적인 개념으로 생각할 수 있고 이를 *추상화 계층*이라고 함

소프트웨어 엔지니어는 문제 해결할 때 아래가 목표 이어야 함

- 복잡한 문제의 하위 문제를 올바르게 식별 및 추상화 계층을 만듦

  - 문제를 하위 문제로 계속 나눠가며 추상화 계층을 만듬
  - 같은 층위는 몇 개의 개념만 다루므로 쉽게 이해

  <details>
  <summary>
  2.2.1 추상화 계층 및 코드 품질의 핵심 요소
  </summary>
  깨끗하고 뚜렷한 추상화 계층 구축 -> 코드 품질의 네 가지 핵심 요소를 달성

  - 가독성

    깨끗하고 뚜렷한 추상화 계층
    -> 한두 개의 계층과 몇 개의 개념만 다루면 됨
    모든 코드 이해 불가능, 하지만 추상화를 이해하면 사용하기 쉬움

  - 모듈화

    하위 문제 해결책을 깔끔하게 나누고 구현 세부 사항이 외부로 노출되지 않을 때  
    -> 다른 계층이나 코드에 영향 미치지 않고 계층 내에서만 구현 변경 쉬워짐

  - 재사용성 및 일반화성

    문제가 적절하게 추상적인 하위 문제로 세분화  
    -> 여러 가지 다른 상황에서 유용하게 일반화

  - 테스트 용이성

    코드가 추상화 계층으로 깨끗하게 분할  
    -> 각 하위 문제가 제대로 작동하는지 확인 -> 신뢰할 수 있는 코드

  </details>

</details>

<details>
<summary>2.3 코드의 계층</summary>

추상화 계층 생성 방법

- 의존성 그래프 생성
  - 코드를 서로 다른 단위로 분할, 단위 간 의존 관계를 보여줌

프로그래밍 언어 코드를 나누는 요소

- 함수
- 클래스(및 구조체, 믹스인 등)
- 인터페이스
- 패키지, 네임스페이스, 모듈

  <details>
  <summary>2.3.1 API 및 구현 세부 사항</summary>
  코드 작성시 고려해야 할 측면 두 가지

  1. 코드를 호출할 때 볼 수 있는 내용

  - 퍼블릭 클래스, 인터페이스 및 함수
  - 이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 개념
  - 코드 호출 시 코드를 올바르게 사용하기 위해 알아야 하는 추가 정보(호출 순서 등)

  2. 코드를 호출할 때 볼 수 없는 내용

  - 구현 세부 사항

  API(application programming interface)

  - 서비스를 사용할 때 알아야할 것들에 대한 개념 형식화
  - 서비스의 모든 구현 세부사항은이 API 뒤에감춘다.

  코드 <- 미니 API 라고 생각하면 유용  
  클래스, 인터페이스, 함수 <- API 노출

  | 공개 API                                      | 구현 세부 사항                                     |
  | --------------------------------------------- | -------------------------------------------------- |
  | 클래스 이름, 퍼블릭 메서드, 반환값 유형, 인수 | 프라이빗 함수, 변수, 함수 내 코드(퍼블릭 함수라도) |

  API 관점에서 위와 같은 방식으로 추상화 계층을 명확하게 만드는데 도움이 됨
  </details>

  <details>
  <summary>2.3.2 함수</summary>
  로직을 새로운 함수로 구현하면 대부분 유익

  하나의 함수에서 너무 많은 개념을 동시에 다루면 코드 이해하기 어려움  
  중첩된 if 문도 마찬가지

  함수가 하는 일을 다음 중 하나로 제한 -> 읽기 쉬운 함수

  - 단일 업무 수행
  - 잘 명명된 다른 함수 호출하여 더 복잡한 동작 구성

  작성된 코드 -> 문장으로 표현 -> 문장이 어렵거나 어색 -> 함수 길음 -> 더 작은 함수로 분리
  -> 작은 로직 쉽게 재사용, 가독성 증가
  </details>

  <details>
  <summary>2.3.3 클래스</summary>
  클래스의 이상적인 크기에 대한 이론, 법칙 제시

  - 줄 수: 예시 '한 클래스는 300줄 넘지 않아야 함' 그보다 길면 너무 많은 개념 다루므로 분리.
    하지만 무엇이 잘못 되었을지도 모른다는 경고의 역할만 함. 상당히 제한적

  - 응집력: 클래스 내의 요소가 잘 속해 있는지 보여주는 척도. 강할수록 좋다. 어떻게 결속되어 있는지 분류 방식 예시

    - 순차적 응집력: 한 요수 출력 -> 다른 요소 입력.  
      예시) 커피 한 잔 만드는 과정. 원두를 갈아야만 커피 추출 가능. 서로 응집력이 있음.

    - 기능적 응집력: 몇 가지 요소들이 모여 하나의 일을 성취하는데 기여.  
      예시) 케이크 만들기. 필요한 모든 장비를 전용 서랍에 보관.

  - 관심사의 분리: 시스템이 각각 별개의 관심사를 다루는 개별 구성 요소로 분리하자는 설계 원칙.  
    예시) 게임 콘솔(게임 실행)과 TV(영상 출력). 동일 제품으로 묶이지 않고 분리됨. 분리 되어 있으므로 한 가지만 업그레이드 가능

  어느 수준 까지 **하나의 사항**으로 간주할지 결정해야함. 주관적이라 까다로움.  
  기존코드를 수정할 때나 완전히 새로운 코드를 작성할 때 클래스가 너무 커지는 것은 아닌지 주의해야 함

  왜 위와 같은 경험 규칙을 적용해야하나? 아래 네 가지 핵심요소로 설명.

  - 코드 가독성: 한 클래스에 많은 개념은 가독성 저하.

  - 코드 모듈화: 하위 문제 해결책 -> 하나의 클래스 + 다른 클래스와 상호작용 준비된 퍼블릭 함수
    -> 다른 클래스로 교체 쉬움

  - 코드 재사용성 및 일반화: 두 하위 문제를 해결해야 할 때, 누가 그 문제를 해결할 상황이 높음.
    두 문제를 한 클래스에 묶으면 이미 구현된 해결책 사용 기회 박탈.

  - 테스트 용이성 및 적절한 테스트: 로직이 여러 클래스로 분리 -> 각 부분 테스트 쉬움

  #### 코드 개선 방법

  ##### 의존성 주입

  의존성 주입이란? 클래스의 생성자를 통해 이 클래스가 의존하는 클래스의 인스턴스 주입  
  예시) 생성자의 매겨변수를 통해 하위 문제를 해결하기 위한 클래스 제공

  예시) TextSummarizer 클래스의 개념

  - 단락을 찾음 <- ParagraphFinder 클래스
  - 중요하지 않은 것은 걸러냄
  - 남아 있는 단락을 연결  
    단락 찾는게 궁금하면 해당 클래스틑 통해 빠르게 파악

  - 코드 모듈화 및 재구성 가능: 단락 중요도 계산을 교체하고 싶으면 사용하던 클래스를 인터페이스로 만들고 이를 구현하는 클래스로 만듬

  - 코드 재사용성 증가: 다른 곳에서 단락을 찾아야 한다면 만든 클래스 재사용

  - 코드 테스트 용이성 증가: 각 하위 문제 클래스에 대해 테스트 쉬움

  네 가지 핵심요소를 충족하는지 고민하며 클래스를 잘 나누자. 추상화 계층을 잘 만드는데 가장 효과적인 도구임

  </details>

  <details>
  <summary>2.3.4 인터페이스</summary>
  어떤 함수를 외부로 노출할 것인지 인터페이스를 통해 결정

  인터페이스 정의 상황 - 하나의 추상화 계층에 대해 다른 방식으로 구현 or 향후 다르게 구현 예상할 경우

  예시) 두 가지 단락 중요도 계산 로직

  - 단어의 중요성 or 기계 학습

  기존 TextImportancescorer 클래스를 인터페이스로 추출
  -> 각 로직에 대해 클래스 구현

  - 상위 클래스의 팩토리 함수로 인스턴스 생성이 용이  
    코드 예시
    ```
    TextSummarizer createWordBasedSummarizer( ) {
      return new TextSummarizer(
        new ParagraphFinder(), new WordBasedScorer ());
    }

    TextSummarizer createModelBasedSummarizer () {
      return new TextSummarizer (
      new ParagraphFinder (), ModelBasedScorer.create());
    }
    ```

  인터페이스 정의 경우 - 주어진 하위 문제를 서로 다른 구현 가능 및 전환이 필요

  <details>
  <summary>모든 것을 위한 인터페이스?</summary>

  주어진 문제에 한 구현 및 추가 구현 계획 없어도 인터페이스를 작성해야 하는가?

  - 너와 너의 팀이 결정할 사안
  - 몇몇 소프트웨어 공학 철학은 그 상황에도 사용 권고.

    - 장점

      1. 퍼블릭 API 매우 명확하게 보여줌
      2. 추측과 다르게 여러 가지 구현이 더 필요할 수 있음
      3. 테스트가 쉬워짐: 클래스가 복잡 or 네트워크 IO 의존 작업이라면 목이나 페이크 객체로 대체할 수 있다. 그러려면 반드시 인터페이스 정의해야 할 수도 있음
      4. 같은 클래스로 두 가지 하위 문제 해결: 한 클래스가 둘 이상 서로 다른 추상화 계층에 구현 제공할 수도 있음

    - 단점
      1. 더 많은 작업 필요: 코드 더 작성, 파일 추가 등
      2. 코드가 복잡해질 수 있음: 클래스를 보는 대신 인터페이스 보고 구현 클래스를 찾아야함

    필자의 인터페이스 사용 방법

    - 사용시 그 장점이 확실한 상황
    - 인터페이스만을 위한 인터페이스 작성 X
    - 클래스라도 퍼블릭 API를 매우 신중. 구현 세부 사항 유출 X
    - 클래스로 작성해도 나중에 인터페이스 붙이기 쉽게 코드 작성

  </details>

  </details>

</details>

<details>
<summary></summary>
</details>
