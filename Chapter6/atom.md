# 6. 예측 가능한 코드를 작성하라

<!-- TOC -->

* [6. 예측 가능한 코드를 작성하라](#6-예측-가능한-코드를-작성하라)
    * [6.1 매직값을 반환하지 말아야 한다](#61-매직값을-반환하지-말아야-한다)
    * [6.2 널 객체 패턴을 적절히 사용하라](#62-널-객체-패턴을-적절히-사용하라)
    * [6.3 예상치 못한 부수 효과를 피하라](#63-예상치-못한-부수-효과를-피하라)
    * [6.4 입력 매개변수를 수정하는 것에 주의하라](#64-입력-매개변수를-수정하는-것에-주의하라)
    * [6.5 오해를 일으키는 함수는 작성하지 말라](#65-오해를-일으키는-함수는-작성하지-말라)
    * [6.6 미래를 대비한 열거형 처리](#66-미래를-대비한-열거형-처리)
    * [6.7 이 모든 것을 테스트로 해결할 수는 없는가?](#67-이-모든-것을-테스트로-해결할-수는-없는가)

<!-- TOC -->

## 6.1 매직값을 반환하지 말아야 한다

- 매직값은 함수의 정상적인 반환 유형에 적합하지만 특별한 의미를 가지고 있다.
- 매직값은 함수의 정상적인 반환 유형에 들어맞기 때문에 이 값이 갖는 특별한 의미를 인지하지 못할 수 있다.
- 매직값은 버그를 유발할 수 있다. 이 경우, 차라리 널, 옵셔널 혹은 오류를 반환하라
- 단, 널과 옵셔널의 경우 값이 없는 이유를 명시적으로 전달하지 않는다는 단점이 존재한다.
- 때때로 매직값은 우연히 발생할 수 있다.

## 6.2 널 객체 패턴을 적절히 사용하라

- 값을 얻을 수 없을 때, 널값이나 빈 옵셔널을 반환하는 대신 널 객체 패턴을 사용할 수 있다.
- 널값을 반환하는 대신 유효한 값이 반환되어 그 이후 실행 로직에서 널값으로 인한 피해를 받지 않도록 하기 위함이다.
- 널 객체 구현은 예상을 벗어나는 동작을 유발할 수 있다.

**(결론) 널 객체 패턴은 여러 형태로 나타날 수 있다. 이것을 사용하거나 접할 때 그것이 정말 적절한지 아니면 예상을 벗어나는 동작을 할 가능성이 있는지에 대해 의식적으로 생각해봐야 한다.**

## 6.3 예상치 못한 부수 효과를 피하라

- 부수 효과는 어떤 함수의 호출이 함수 외부에 초래한 상태 변화를 의미한다.
- 분명하고 의도적인 부수 효과는 괜찮다. 하지만, 예기치 않은 부수 효과는 문제가 될 수 있다.
- 예기치 않은 부수 효과는 문제가 될 수 있다.
- 예기치 못한 부수 효과가 문제의 소지가 될 수 있는 몇 가지 경우가 존재한다.
    - 부수 효과는 비용이 많이 들 수 있다.
    - 호출한 쪽의 가정을 깨트린다.
    - 다중 스레드 코드의 버그를 발생 시킨다.

**(결론) 부수 효과를 피하거나 그 사실을 분명하게 하라. 부수효과를 피할 수 없을 때 적절하게 이름을 짓는 것은 그 사실을 명백하게 나타내는 효과적인 방법이다.**

## 6.4 입력 매개변수를 수정하는 것에 주의하라

- 입력 매개변수를 수정하면 버그를 초래할 수 있다.
- 입력 매개변수로 들어온 객체는 함수가 호출된 뒤에도 해당 객체를 다른 용도로 사용할 가능성이 존재한다.
- 입력 매개변수를 수정하는 것은 함수가 외부의 무언가에 영향을 미치기 때문에 부수 효과의 또 다른 예시이다.

**(결론) 변경하기 전에 복사하라. 만약, 성능 문제로 인해 불가하다면 문서에나 함수 이름 매개변수에 동작을 분명히 하는 것이 좋다.**

## 6.5 오해를 일으키는 함수는 작성하지 말라

**(결론) 중요한 입력은 필수 항목으로 만들자. + 코드를 명확하게 작성하는 것의 이점은 코드를 몇 줄 더 추가하는 비용을 훨씬 능가한다.**

## 6.6 미래를 대비한 열거형 처리

- 미래에 추가될 수 있는 열것값을 암묵적으로 처리하는 것은 문제가 될 수 있다. 대신, 모든 경우를 처리하는 스위치 문을 사용하자.
- 기본 케이스를 주의하자. 열거형을 처리하는 스위치 문에 기본 케이스를 추가하면 향후 열거형 값이 암시적으로 처리될 수 있기 때문이다.(잠재적으로 예기치 않은 문제와 버그 발생 가능)
- 기본 케이스에서 예외 발생도 나쁘진 않지만, 컴파일러가 모든 열것값이 처리되는 것으로 판단한다.
- 주의 사항 : 다른 프로젝트의 열거형에 의존

## 6.7 이 모든 것을 테스트로 해결할 수는 없는가?

- 테스트만으로는 이것을 보증하기에 충분하지 않을 수 있다.
- 어떤 개발자는 테스트에 그다지 부지런하지 않을 수 있다.
- 테스트가 항상 실제 상황을 정확하게 시뮬레이션하는 것은 아니다.
- 테스트가 항상 가능한 것은 아니다.

**(결론) 테스트만으로는 예측을 벗어나는 코드의 문제를 해결할 수 없다. 다른 개발자가 코드를 잘못 해석하면 테스트해야 할 시나리오도 잘못 이해할 수 있다.**
