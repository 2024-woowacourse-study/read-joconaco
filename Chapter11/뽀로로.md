# 11. 단위 테스트의 실제

---

## 11.1 기능뿐만 아니라 동작을 시험하라 
코드가 보이는 중요한 행동을 모두 테스트해야 한다.

함수별로 테스트 케이스를 하나만 작성하면 중요한 동작을 놓칠 수 있다.
단순히 눈에 보이는 대로 함수 이름을 테스트 목록에 넣기보다는 함수가 수행하는 모든 동작으로 목록을 채우는 것이 좋다.

### 11.1.1 함수당 하나의 테스트 케이스만 있으면 적절하지 않을 때가 많다
다른 많은 사항을 테스트하지 않은 채로 남겨두면 충분한 테스트가 아니다.

해결책: 각 동작을 테스트하는 데 집중하라 

코드에 대한 신뢰도를 높이기 위해 여러 가지 값과 경계 조건을 테스트하는 것이 타당하다.

테스트를 올바르게 확인하기 위해 다음과 같이 생각해야 된다.
- 모든 동작이 테스트되었는지 거듭 확인하라
- 오류 시나리오를 잊지 말라

## 11.2 테스트만을 위해 퍼블릭으로 만들지 말라
프라이빗 함수는 구현 세부 사항이면 클래스 외부의 코드가 인지하거나 직접 사용하는 것이 아니다.
때로는 이러한 프라이빗 함수 중 일부를 테스트 코드에서도 접근할 수 있도록 만들어 직접 테스트하고자 할 수 있다.
그러나 이는 **좋은 생각이 아닐 때**가 많다.
구현 세부 사항과 밀접하게 연관된 테스트가 될 수 있고 궁극적으로 우리가 신경 써야 하는 코드의 동작을 테스트하지 않을 수 있기 때문이다.

### 11.2.1 프라이빗 함수를 테스트하는 것은 바람직하지 않을 때가 많다.
프라이빗 함수를 퍼블릭으로 만든 후에 테스트할 때의 문제는 다음과 같다.
- 실제로 우리가 신경 쓰는 행동을 테스트하는 것이 아니다
- 구현 세부 사항에 독립적이지 못하게 된다.
- 퍼블릭 API를 변경한 효과를 갖는다.

좋은 단위 테스트는 궁극적으로 중요한 행동을 테스트해야 한다.
이렇게 하면 테스트는 코드의 문제점을 정확하게 감지할 가능성을 극대화하며 구현 세부 사항에 독립적으로 된다.

### 11.2.2 해결책: 퍼블릭 API를 통해 테스트하라 && 11.2.3 해결책: 코드를 더 작은 단위로 분할하라
비교적 간단한 클래스의 경우 퍼블릭 API만을 사용하여 모든 동작을 테스트하기가 매우 쉽다.
그러나 클래스가 더 복잡하거나 많은 논리를 포함하면 퍼블릭 API를 통해 모든 동작을 테스트하는 것이 까다로울 수 있다.
이 경우는 코드의 추상화 계층이 너무 크다는 것을 의미하기 때문에 코드를 더 작은 단위로 분할하는 것이 유익하다.

## 11.3 한 번에 하나의 동작만 테스트하라
여러 동작을 한꺼번에 테스트하면 테스트가 제대로 안 될 수 있다.

모든 것을 한꺼번에 테스트하는 테스트 케이스는 정확히 무엇이 변경됐는지 알려주는 대신, 무언가 변경됐다는 것만 알려준다.
따라서 코드를 의도적으로 변경할 때 그 변경으로 인해 어떤 동작이 영향을 받았고 어떤 동작이 영향을 받지 않았는지 정확히 알기 어렵다.

>해결책: 각 동작은 자체 테스트 케이스에서 테스트하라

각 동작을 개별적으로 테스트하고 각 테스트 케이스에 적절한 이름을 사용하면 테스트가 실패할 경우 어떤 동작이 실패했는지 잘 알 수 있다.

각 동작을 하나의 테스트 케이스로 테스트하면 장점이 있지만, 코드 중복이 많아지는 단점도 있다.
이런 코드 중복을 줄이는 한 가지 방법은 매개변수화된 테스트를 사용하는 것이다.

## 11.4 공유 설정을 적절하게 사용하라
테스트 케이스는 의존성을 설정하거나 테스트 데이터 저장소에 값을 채우거나 다른 종류의 상태를 초기화하는 등 어느 정도의 설정이 필요할 때가 있다.

테스트 프레임워크에서 테스트 케이스 간에 이 설정을 쉽게 공유할 수 있는 기능을 제공한다.
- BeforeAll: 테스트 케이스가 실행되기 전에 단 한 번 실행된다. 'OneTimeSetUp'
- BeforeEach: 각 테스트 케이스가 실행되기 전에 매번 실행한다. 'SetUp'

공유 설정을 해체하는 방법도 제공한다.
- AfterAll: 모든 테스트 케이스가 실행된 후 코드가 한 번 실행된다. 'OneTimeTearDown'
- AfterEach: 각 테스트 케이스가 실행된 후에 매번 실행된다. 'TearDown'

이와 같은 설정 코드 블록을 사용하면 설정을 서로 다른 테스트 케이스 간에 공유할 수 있다.
이것은 두 가지 중요한 방식으로 일어날 수 있다.
- 상태 공유
- 설정 공유

### 11.4.1 상태 공유는 문제가 될 수 있다.
일반적으로 테스트 케이스는 서로 격리되어야 하므로 한 테스트 케이스가 수행하는 모든 조치는 다른 테스트 케이스의 결과에 영향을 미치지 않아야 한다.
테스트 케이스 간에 상태를 공유하고 이 상태가 가변적이면 이 규칙을 실수로 위반하기 쉽다.

해결책: 상태를 공유하지 않거나 초기화하라

### 11.4.3 설정 공유는 문제가 될 수 있다.
설정을 공유하면 어떤 테스트 케이스가 어떤 특정 항목에 의존하는지 정확하게 추적하는 것은 매우 어려우며,
향후 변경 사항이 발생하면 테스트 케이스가 원래 목적했던 동작을 더 이상 테스트하지 않게 될 수 있다.

해결책: 중요한 설정은 테스트 케이스 내에서 정의하라

## 11.5 적절한 어서션 확인자를 사용하라
부적합한 확인자는 테스트 실패를 잘 설명하지 못할 수 있다.

테스트는 코드에 정말로 문제가 있을 때에만 테스트가 실패하고 `실패의 이유가 잘 설명`돼야 한다.
이 목표를 달성하기 위해 적절한 어서션 확인자를 선택할 필요가 있다.

## 11.6 테스트 용이성을 위해 의존성 주입을 사용하라
하드 코딩된 의존성은 테스트를 불가능하게 할 수 있다.

>해결책: 의존성 주입을 사용하라 

의존성 주입은 코드를 좀더 모듈화하기 위한 효과적인 기술이며, 따라서 코드의 테스트 용이성을 높이기 위한 효과적인 기술이다.

## 11.7 테스트에 대한 몇 가지 결론
개발자로서 접하고 사용할 가능성이 큰 다른 두 가지 테스트 수준은 다음과 같다.
- 통합 테스트(integration test): 한 시스템은 일바적으로 여러 구성 요소, 모듈, 하위 시스템으로 구성된다. 이러한 구성 요소와 하위 시스템을 서로 연결하는 프로세스를 통합이라고 한다. 통합 테스트는 이러한 통합이 제대로 작동하는지 확인하기 위한 테스트다.
- 종단 간 테스트(end-to-end test): 처음부터 끝까지 전체 소프트웨어 시스템을 통과하는 여정을 테스트한다.

다양한 유형의 테스트
- 회귀 테스트(regression test): 소프트웨어의 동작이나 기능이 바람직하지 않은 방식으로 변경되지 않았는지 확인하기 위해 정기적으로 수행하는 테스트이다.
- 골든 테스트(golden test): 특성화 테스트라고도 하며, 일반적으로 주어진 입력 집합에 대해 코드가 생성한 출력을 스냅샷으로 저장한 것을 기반으로 한다. 테스트 수행 후 코드가 생성한 출력이 다르면 테스트는 실패한다.
- 퍼즈 테스트(fuzz test): 많은 무작위 값이나 흥미로운 값으로 코드를 호출하고 그들 중 어느 것도 코드의 동작을 멈추지 않는지 점검한다.

## 요약
- 각 함수를 테스트하는 것에 집중하다 보면 테스트가 충분히 되지 못하기 쉽다. 보통은 모든 중요한 행동을 파악하고 각각의 테스트 케이스를 작성하는 것이 더 효과적이다.
- 결과적으로 중요한 동작을 테스트해야 한다. 프라이빗 함수를 테스트하는 것은 거의 대부분 결과적으로 중요한 사항을 테스트하는 것이 아니다.
- 한 번에 한 가지씩만 테스트하면 테스트 실패의 이유를 더 잘 알 수 있고 테스트 코드를 이해하기가 더 쉽다.
- 테스트 설정 공유는 양날의 검이 될 수 있다. 코드 반복이나 비용이 큰 설정을 피할 수 있지만 부적절하게 사용할 경우 효과적이지 못하거나 신뢰할 수 없는 결과를 초래할 수 있다.
- 의존성 주입을 사용하면 코드의 테스트 용이성이 상당히 향상될 수 있다.
- 단위 테스트는 개발자들이 가장 자주 다루는 테스트 수준이지만 이것만이 유일한 테스트는 아니다. 높은 품질의 소프트웨어를 작성하고 유지하려면 여러 가지 테스트 기술을 함께 사용해야 할 때가 많다.
